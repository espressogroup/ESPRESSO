{"version":3,"file":"jose.min.js","mappings":"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","sources":["webpack://JOSE/./node_modules/base64url/dist/base64url.js","webpack://JOSE/./node_modules/base64url/dist/pad-string.js","webpack://JOSE/./node_modules/base64url/index.js","webpack://JOSE/./src/algorithms/ECDSA.js","webpack://JOSE/./src/algorithms/HMAC.js","webpack://JOSE/./src/algorithms/NONE.js","webpack://JOSE/./src/algorithms/RSASSA-PKCS1-v1_5.js","webpack://JOSE/./src/algorithms/SupportedAlgorithms.js","webpack://JOSE/./src/algorithms/index.js","webpack://JOSE/./src/crypto.js","webpack://JOSE/./src/errors/DataError.js","webpack://JOSE/./src/errors/NotSupportedError.js","webpack://JOSE/./src/errors/index.js","webpack://JOSE/./src/index.js","webpack://JOSE/./src/jose/JOSEHeader.js","webpack://JOSE/./src/jose/JWA.js","webpack://JOSE/./src/jose/JWK.js","webpack://JOSE/./src/jose/JWKSet.js","webpack://JOSE/./src/jose/JWS.js","webpack://JOSE/./src/jose/JWT.js","webpack://JOSE/./src/text-encoder/index.js","webpack://JOSE/external var \"TextEncoder\"","webpack://JOSE/external var \"crypto\"","webpack://JOSE/webpack/bootstrap","webpack://JOSE/webpack/runtime/global","webpack://JOSE/webpack/startup"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar pad_string_1 = require(\"./pad-string\");\nfunction encode(input, encoding) {\n    if (encoding === void 0) { encoding = \"utf8\"; }\n    if (Buffer.isBuffer(input)) {\n        return fromBase64(input.toString(\"base64\"));\n    }\n    return fromBase64(Buffer.from(input, encoding).toString(\"base64\"));\n}\n;\nfunction decode(base64url, encoding) {\n    if (encoding === void 0) { encoding = \"utf8\"; }\n    return Buffer.from(toBase64(base64url), \"base64\").toString(encoding);\n}\nfunction toBase64(base64url) {\n    base64url = base64url.toString();\n    return pad_string_1.default(base64url)\n        .replace(/\\-/g, \"+\")\n        .replace(/_/g, \"/\");\n}\nfunction fromBase64(base64) {\n    return base64\n        .replace(/=/g, \"\")\n        .replace(/\\+/g, \"-\")\n        .replace(/\\//g, \"_\");\n}\nfunction toBuffer(base64url) {\n    return Buffer.from(toBase64(base64url), \"base64\");\n}\nvar base64url = encode;\nbase64url.encode = encode;\nbase64url.decode = decode;\nbase64url.toBase64 = toBase64;\nbase64url.fromBase64 = fromBase64;\nbase64url.toBuffer = toBuffer;\nexports.default = base64url;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction padString(input) {\n    var segmentLength = 4;\n    var stringLength = input.length;\n    var diff = stringLength % segmentLength;\n    if (!diff) {\n        return input;\n    }\n    var position = stringLength;\n    var padLength = segmentLength - diff;\n    var paddedStringLength = stringLength + padLength;\n    var buffer = Buffer.alloc(paddedStringLength);\n    buffer.write(input);\n    while (padLength--) {\n        buffer.write(\"=\", position++);\n    }\n    return buffer.toString();\n}\nexports.default = padString;\n","module.exports = require('./dist/base64url').default;\nmodule.exports.default = module.exports;\n","'use strict'\n\n/**\n * Dependencies\n * @ignore\n */\nconst base64url = require('base64url')\nconst crypto = require('isomorphic-webcrypto')\nconst TextEncoder = require('../text-encoder')\n\n/**\n * ECDSA with SHA-2 Functions and P Curves\n */\nclass ECDSA {\n\n  /**\n   * Constructor\n   *\n   * @param {string} bitlength\n   */\n  constructor (params) {\n    this.params = params\n  }\n\n  /**\n   * Sign\n   *\n   * @description\n   * Generate a hash-based message authentication code for a\n   * given input and key. Enforce the key length is equal to\n   * or greater than the bitlength.\n   *\n   * @param {CryptoKey} key\n   * @param {string} data\n   *\n   * @returns {string}\n   */\n  sign (key, data) {\n    let algorithm = this.params\n\n    // TODO: validate key length\n\n    data = new TextEncoder().encode(data)\n\n    return crypto.subtle\n      .sign(algorithm, key, data)\n      .then(signature => base64url(Buffer.from(signature)))\n  }\n\n  /**\n   * Verify\n   *\n   * @description\n   * Verify a digital signature for a given input and private key.\n   *\n   * @param {CryptoKey} key\n   * @param {string} signature\n   * @param {string} data\n   *\n   * @returns {Boolean}\n   */\n  verify (key, signature, data) {\n    let algorithm = this.params\n\n    if (typeof signature === 'string') {\n      signature = Uint8Array.from(base64url.toBuffer(signature))\n    }\n\n    if (typeof data === 'string') {\n      data = new TextEncoder().encode(data)\n    }\n\n    return crypto.subtle.verify(algorithm, key, signature, data)\n  }\n\n  /**\n   * Assert Sufficient Key Length\n   *\n   * @description Assert that the key length is sufficient\n   * @param {string} key\n   */\n  assertSufficientKeyLength (key) {\n    if (key.length < this.bitlength) {\n      throw new Error('The key is too short.')\n    }\n  }\n\n  /**\n   * importKey\n   * copied from ./RSASSA-PKCS1-v1_5.js, and it works!\n   *\n   * @param {JWK} key\n   * @returns {Promise}\n   */\n  async importKey (key) {\n    let jwk = Object.assign({}, key)\n    let algorithm = this.params\n    let usages = key['key_ops'] || []\n\n    if (key.use === 'sig') {\n      usages.push('verify')\n    }\n\n    if (key.use === 'enc') {\n      // TODO: handle encryption keys\n      return Promise.resolve(key)\n    }\n\n    if (key.key_ops) {\n      usages = key.key_ops\n    }\n\n    return crypto.subtle\n      .importKey('jwk', jwk, algorithm, true, usages)\n      .then(cryptoKey => {\n        Object.defineProperty(jwk, 'cryptoKey', {\n          enumerable: false,\n          value: cryptoKey\n        })\n\n        return jwk\n      })\n  }\n}\n\n/**\n * Export\n */\nmodule.exports = ECDSA\n","'use strict'\n\n/**\n * Dependencies\n * @ignore\n */\nconst base64url = require('base64url')\nconst crypto = require('isomorphic-webcrypto')\nconst TextEncoder = require('../text-encoder')\n\n/**\n * HMAC with SHA-2 Functions\n */\nclass HMAC {\n\n  /**\n   * Constructor\n   *\n   * @param {string} bitlength\n   */\n  constructor (params) {\n    this.params = params\n  }\n\n  /**\n   * Sign\n   *\n   * @description\n   * Generate a hash-based message authentication code for a\n   * given input and key. Enforce the key length is equal to\n   * or greater than the bitlength.\n   *\n   * @param {CryptoKey} key\n   * @param {string} data\n   *\n   * @returns {string}\n   */\n  sign (key, data) {\n    let algorithm = this.params\n\n    // TODO: validate key length\n\n    data = new TextEncoder().encode(data)\n\n    return crypto.subtle\n      .sign(algorithm, key, data)\n      .then(signature => base64url(Buffer.from(signature)))\n  }\n\n  /**\n   * Verify\n   *\n   * @description\n   * Verify a digital signature for a given input and private key.\n   *\n   * @param {CryptoKey} key\n   * @param {string} signature\n   * @param {string} data\n   *\n   * @returns {Boolean}\n   */\n  verify (key, signature, data) {\n    let algorithm = this.params\n\n    if (typeof signature === 'string') {\n      signature = Uint8Array.from(base64url.toBuffer(signature))\n    }\n\n    if (typeof data === 'string') {\n      data = new TextEncoder().encode(data)\n    }\n\n    return crypto.subtle.verify(algorithm, key, signature, data)\n  }\n\n  /**\n   * Assert Sufficient Key Length\n   *\n   * @description Assert that the key length is sufficient\n   * @param {string} key\n   */\n  assertSufficientKeyLength (key) {\n    if (key.length < this.bitlength) {\n      throw new Error('The key is too short.')\n    }\n  }\n}\n\n/**\n * Export\n */\nmodule.exports = HMAC\n","/**\n * None\n */\nclass None {\n  /**\n   * sign\n   */\n  sign () {\n    return Promise.resolve('')\n  }\n\n  /**\n   * verify\n   */\n  verify () {\n    // this will never get called. but you looked.\n  }\n}\n\n/**\n * Export\n */\nmodule.exports = None\n","'use strict'\n\n/**\n * Dependencies\n * @ignore\n */\nconst base64url = require('base64url')\nlet crypto = require('../crypto')\nconst TextEncoder = require('../text-encoder')\n\n/**\n * RSASSA-PKCS1-v1_5\n */\nclass RSASSA_PKCS1_v1_5 {\n\n  /**\n   * constructor\n   *\n   * @param {string} bitlength\n   */\n  constructor (params) {\n    this.params = params\n  }\n\n  /**\n   * sign\n   *\n   * @description\n   * Generate a digital signature for a given input and private key.\n   *\n   * @param {CryptoKey} key\n   * @param {BufferSource} data\n   *\n   * @returns {Promise}\n   */\n  sign (key, data) {\n    let algorithm = this.params\n\n    // TODO\n    //if (!this.sufficientKeySize()) {\n    //  return Promise.reject(\n    //    new Error(\n    //      'A key size of 2048 bits or larger must be used with RSASSA-PKCS1-v1_5'\n    //    )\n    //  )\n    //}\n\n    data = new TextEncoder().encode(data)\n\n    return crypto.subtle\n      .sign(algorithm, key, data)\n      .then(signature => base64url(Buffer.from(signature)))\n  }\n\n  /**\n   * verify\n   *\n   * @description\n   * Verify a digital signature for a given input and private key.\n   *\n   * @param {CryptoKey} key\n   * @param {BufferSource} signature\n   * @param {BufferSource} data\n   *\n   * @returns {Promise}\n   */\n  verify (key, signature, data) {\n    let algorithm = this.params\n\n    if (typeof signature === 'string') {\n      signature = Uint8Array.from(base64url.toBuffer(signature))\n    }\n\n    if (typeof data === 'string') {\n      data = new TextEncoder().encode(data)\n    }\n    // ...\n\n    return crypto.subtle.verify(algorithm, key, signature, data)\n  }\n\n  /**\n   * importKey\n   *\n   * @param {JWK} key\n   * @returns {Promise}\n   */\n  async importKey (key) {\n    let jwk = Object.assign({}, key)\n    let algorithm = this.params\n    let usages = key['key_ops'] || []\n\n    if (key.use === 'sig') {\n      usages.push('verify')\n    }\n\n    if (key.use === 'enc') {\n      // TODO: handle encryption keys\n      return Promise.resolve(key)\n    }\n\n    if (key.key_ops) {\n      usages = key.key_ops\n    }\n\n    return crypto.subtle\n      .importKey('jwk', jwk, algorithm, true, usages)\n      .then(cryptoKey => {\n        Object.defineProperty(jwk, 'cryptoKey', {\n          enumerable: false,\n          value: cryptoKey\n        })\n\n        return jwk\n      })\n  }\n}\n\n/**\n * Export\n */\nmodule.exports = RSASSA_PKCS1_v1_5\n","/**\n * Dependencies\n */\nconst NotSupportedError = require('../errors/NotSupportedError')\n\n/**\n * Operations\n */\nconst operations = [\n  'sign',\n  'verify',\n  'encrypt',\n  'decrypt',\n  'importKey'\n]\n\n/**\n * SupportedAlgorithms\n */\nclass SupportedAlgorithms {\n\n  /**\n   * constructor\n   */\n  constructor () {\n    operations.forEach(op => {\n      this[op] = {}\n    })\n  }\n\n  /**\n   * Supported Operations\n   */\n  static get operations () {\n    return operations\n  }\n\n  /**\n   * define\n   *\n   * @description\n   * Register Web Crypto API algorithm parameter for an algorithm\n   * and operation.\n   *\n   * @param {string} alg\n   * @param {string} op\n   * @param {Object} argument\n   */\n  define (alg, op, argument) {\n    let registeredAlgorithms = this[op]\n    registeredAlgorithms[alg] = argument\n  }\n\n  /**\n   * normalize\n   *\n   * @description\n   * Map JWA alg name to Web Crypto API algorithm parameter\n   *\n   * @param {string} op\n   * @param {Object} alg\n   *\n   * @returns {Object}\n   */\n  normalize (op, alg) {\n    let registeredAlgorithms = this[op]\n\n    if (!registeredAlgorithms) {\n      return new SyntaxError() // what kind of error should this be?\n    }\n\n    let argument = registeredAlgorithms[alg]\n\n    if (!argument) {\n      return new NotSupportedError(alg)\n    }\n\n    return argument\n  }\n}\n\n/**\n * Export\n */\nmodule.exports = SupportedAlgorithms\n","/**\n * Local dependencies\n */\nconst None = require('./NONE')\nconst HMAC = require('./HMAC')\nconst RSASSA_PKCS1_v1_5 = require('./RSASSA-PKCS1-v1_5')\nconst ECDSA = require('./ECDSA')\nconst SupportedAlgorithms = require('./SupportedAlgorithms')\n\n/**\n * Register Supported Algorithms\n */\nconst supportedAlgorithms = new SupportedAlgorithms\n\n/**\n * Sign\n */\nsupportedAlgorithms.define('HS256', 'sign', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-256'\n  }\n}))\n\nsupportedAlgorithms.define('HS384', 'sign', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-384'\n  }\n}))\n\nsupportedAlgorithms.define('HS512', 'sign', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-512'\n  }\n}))\n\nsupportedAlgorithms.define('RS256', 'sign', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-256'\n  }\n}))\n\nsupportedAlgorithms.define('RS384', 'sign', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-384'\n  }\n}))\n\nsupportedAlgorithms.define('RS512', 'sign', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-512'\n  }\n}))\n\nsupportedAlgorithms.define('ES256', 'sign', new ECDSA({\n  name: 'ECDSA',\n  hash: {\n    name: 'SHA-256'\n  },\n  namedCurve: 'P-256'\n}))\n//supportedAlgorithms.define('ES384', 'sign', {})\n//supportedAlgorithms.define('ES512', 'sign', {})\n//supportedAlgorithms.define('PS256', 'sign', {})\n//supportedAlgorithms.define('PS384', 'sign', {})\n//supportedAlgorithms.define('PS512', 'sign', {})\n\nsupportedAlgorithms.define('none', 'sign', new None({\n  // nothing goes here\n}))\n\n/**\n * Verify\n */\nsupportedAlgorithms.define('HS256', 'verify', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-256'\n  }\n}))\n\nsupportedAlgorithms.define('HS384', 'verify', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-384'\n  }\n}))\n\nsupportedAlgorithms.define('HS512', 'verify', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-512'\n  }\n}))\n\nsupportedAlgorithms.define('RS256', 'verify', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-256'\n  }\n}))\n\nsupportedAlgorithms.define('RS384', 'verify', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-384'\n  }\n}))\n\nsupportedAlgorithms.define('RS512', 'verify', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-512'\n  }\n}))\n\nsupportedAlgorithms.define('ES256', 'verify', new ECDSA({\n  name: 'ECDSA',\n  hash: {\n    name: 'SHA-256'\n  },\n  namedCurve: 'P-256'\n}))\n//supportedAlgorithms.define('ES384', 'verify', {})\n//supportedAlgorithms.define('ES512', 'verify', {})\n//supportedAlgorithms.define('PS256', 'verify', {})\n//supportedAlgorithms.define('PS384', 'verify', {})\n//supportedAlgorithms.define('PS512', 'verify', {})\n\nsupportedAlgorithms.define('none', 'verify', new None({\n  // nothing goes here\n}))\n\nsupportedAlgorithms.define('RS256', 'importKey', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-256'\n  }\n}))\n\nsupportedAlgorithms.define('RS384', 'importKey', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-384'\n  }\n}))\n\nsupportedAlgorithms.define('RS512', 'importKey', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-512'\n  }\n}))\n\nsupportedAlgorithms.define('ES256', 'importKey', new ECDSA({\n  name: 'ECDSA',\n  hash: {\n    name: 'SHA-256'\n  },\n  namedCurve: 'P-256'\n}))\n\n/**\n * Export\n */\nmodule.exports = supportedAlgorithms\n\n\n","const imported = require('isomorphic-webcrypto')\n\nmodule.exports = (imported.default ? imported.default : imported)\n","/**\n * DataError\n */\nclass DataError extends Error {\n  constructor (message) {\n    super(message)\n  }\n}\n\n/**\n * Export\n */\nmodule.exports = DataError\n","/**\n * NotSupportedError\n */\nclass NotSupportedError extends Error {\n  constructor (alg) {\n    super()\n    this.message = `${alg} is not a supported algorithm`\n  }\n}\n\n/**\n * Export\n */\nmodule.exports = NotSupportedError\n","module.exports = {\n  DataError: require('./DataError'),\n  NotSupportedError: require('./NotSupportedError')\n}\n","/**\n * @module JSON Object Signing and Encryption (JOSE)\n */\nconst crypto = require('./crypto')\nconst JWA = require('./jose/JWA')\nconst JWK = require('./jose/JWK')\nconst JWKSet = require('./jose/JWKSet')\nconst JWT = require('./jose/JWT')\nconst JWS = require('./jose/JWS')\n\n/**\n * Export\n */\nmodule.exports = {\n  crypto,\n  JWA,\n  JWK,\n  JWKSet,\n  JWT,\n  JWS\n}\n","/**\n * Header\n */\nclass JOSEHeader {\n  constructor ({ typ, cty, alg, jku, kid, x5u, x5c, x5t, crit, enc, zip } = {}) {\n    this.typ = typ\n    this.cty = cty\n    this.alg = alg\n    this.jku = jku\n    this.kid = kid\n    this.x5u = x5u\n    this.x5c = x5c\n    this.x5t = x5t\n    this.crit = crit\n    this.enc = enc\n    this.zip = zip\n  }\n\n  /**\n   * isJWS\n   */\n  isJWS () {}\n\n  /**\n   * isJWE\n   */\n  isJWE () {}\n}\n\n/**\n * Export\n */\nmodule.exports = JOSEHeader\n","/**\n * Dependencies\n *\n * TODO\n * - switch between Node.js webcrypto package and browser implementation\n */\n// const base64url = require('base64url')\nconst supportedAlgorithms = require('../algorithms')\nconst {NotSupportedError} = require('../errors')\n\n/**\n * JWA\n * https://tools.ietf.org/html/rfc7518\n */\nclass JWA {\n\n  /**\n   * Sign\n   *\n   * @description\n   * Create a digital signature.\n   *\n   * @param {string} alg\n   * @param {CryptoKey} key\n   * @param {string|Buffer} data\n   *\n   * @return {Promise}\n   */\n  static async sign (alg, key, data) {\n    // normalize the algorithm\n    let normalizedAlgorithm = supportedAlgorithms.normalize('sign', alg)\n\n    // validate algorithm is supported\n    if (normalizedAlgorithm instanceof Error) {\n      return Promise.reject(new NotSupportedError(alg))\n    }\n\n    // validate type of key\n    // TODO\n    //  - is the key suitable for the algorithm?\n    //  - does that get validated in webcrypto?\n    //if (key instanceof CryptoKey) {\n    //  return Promise.reject(new InvalidKeyError())\n    //}\n\n    // sign the data\n    return normalizedAlgorithm.sign(key, data)\n  }\n\n  /**\n   * Verify\n   *\n   * @description\n   * Verify a digital signature.\n   *\n   * @param {string} alg\n   * @param {CryptoKey} privateKey\n   * @param {string|Buffer} signature\n   * @param {string|Buffer} data\n   *\n   * @return {Promise}\n   */\n  static async verify (alg, key, signature, data) {\n    let normalizedAlgorithm = supportedAlgorithms.normalize('verify', alg)\n\n    if (normalizedAlgorithm instanceof Error) {\n      return Promise.reject(new NotSupportedError(alg))\n    }\n\n    // TODO\n    // validate publicKey\n\n    // verify the signature\n    return normalizedAlgorithm.verify(key, signature, data)\n  }\n\n  /**\n   * Encrypt\n   */\n\n  /**\n   * Decrypt\n   */\n\n  /**\n   * Import\n   */\n  static async importKey (key) {\n    let normalizedAlgorithm = supportedAlgorithms.normalize('importKey', key.alg)\n    return normalizedAlgorithm.importKey(key)\n  }\n}\n\n/**\n * Export\n */\nmodule.exports = JWA\n","'use strict'\n\n/**\n * Dependencies\n * @ignore\n */\nconst JWA = require('./JWA')\n\n/**\n * JWK Class\n */\nclass JWK {\n  constructor ({ kty, use, key_ops, alg, kid, x5u, x5c, x5t } = {}) {\n    this.kty = kty\n    this.use = use\n    this.key_ops = key_ops\n    this.alg = alg\n    this.kid = kid\n    this.x5u = x5u\n    this.x5c = x5c\n    this.x5t = x5t\n  }\n\n  /**\n   * importKey\n   *\n   * TODO:\n   * - should this be on JWA?\n   */\n  static async importKey (jwk) {\n    return JWA.importKey(jwk)\n  }\n\n\n}\n\n/**\n * Export\n */\nmodule.exports = JWK\n","'use strict'\n\n/**\n * Dependencies\n */\nconst JWK = require('./JWK')\n\n/**\n * JWKSet\n *\n * @class\n * JWKSet represents a JSON Web Key Set as described in Section 5 of RFC 7517:\n * https://tools.ietf.org/html/rfc7517#section-5\n */\nclass JWKSet {\n  constructor ({ keys } = {}) {\n    this.keys = keys\n  }\n\n  /**\n   * importKeys\n   */\n  static async importKeys (jwks) {\n    if (!jwks.keys) {\n      return Promise.reject(new Error('Cannot import JWKSet: keys property is empty'))\n    }\n\n    let imported, importing\n\n    try {\n      imported = new JWKSet(jwks)\n      importing = jwks.keys.map(key => JWK.importKey(key))\n    } catch (err) {\n      return Promise.reject(err)\n    }\n\n    return Promise.all(importing)\n      .then(keys => {\n        imported.keys = keys\n        return imported\n      })\n  }\n}\n\n/**\n * Export\n */\nmodule.exports = JWKSet\n","/**\n * Dependencies\n */\nconst base64url = require('base64url')\nconst JWA = require('./JWA')\nconst { DataError } = require('../errors')\nconst JOSEHeader = require('./JOSEHeader')\n\n/**\n * JWS\n */\nclass JWS {\n  constructor (data = {}) {\n    // compact\n    this.header = new JOSEHeader(data.header)\n    this.payload = data.payload || {}\n    this.signature = data.signature\n\n    // flattened\n    this.protected = data.protected\n\n    // JSON serialization\n    this.signatures = data.signatures\n\n    this.verified = false\n  }\n\n  /**\n   * sign\n   *\n   * @description\n   * Encode a JWT instance\n   *\n   * @param {Object} token\n   * @returns {Promise}\n   */\n  static async sign (token) {\n    let payload = base64url(JSON.stringify(token.payload))\n\n    // compact serialization\n    if (token.serialization === 'compact') {\n      let {key, header: {alg}} = token\n      let header = base64url(JSON.stringify(token.header))\n      let data = `${header}.${payload}`\n\n      return JWA.sign(alg, key, data).then(signature => `${data}.${signature}`)\n    }\n\n    // JSON serialization\n    if (token.serialization === 'json') {\n\n    }\n\n    // Flattened serialization\n    if (token.serialization === 'flattened') {\n\n    }\n\n    return Promise.reject(new DataError('Unsupported serialization'))\n  }\n\n  /**\n   * verify\n   */\n  static async verify (jwt) {\n    // multiple signatures\n    if (jwt.signatures) {\n      // ...\n    }\n\n    let {key, signature, header: {alg}} = jwt\n\n    // one signature\n    if (jwt.signature) {\n      let [header, payload] = jwt.segments\n      let data = `${header}.${payload}`\n\n      if (alg === 'none') {\n        return Promise.reject(new DataError('Signature provided to verify with alg: none'))\n      }\n\n      return JWA.verify(alg, key, signature, data).then(verified => {\n        jwt.verified = verified\n        return verified\n      })\n    }\n\n    if (alg === 'none') {\n      if (!key && !signature) {\n        jwt.verified = true\n\n        return Promise.resolve(true)\n      }\n\n      if (key) {\n        return Promise.reject(new DataError('Key provided to verify signature with alg: none'))\n      }\n    }\n\n    // no signatures to verify\n    return Promise.reject(new DataError('Missing signature(s)'))\n  }\n}\n\n/**\n * Export\n */\nmodule.exports = JWS\n","/**\n * Dependencies\n */\nconst base64url = require('base64url')\nconst JWS = require('./JWS')\nconst DataError = require('../errors/DataError')\nconst JOSEHeader = require('./JOSEHeader')\n\n/**\n * JWT\n */\nclass JWT {\n  constructor (data = {}) {\n    this.type = data.type\n    this.segments = data.segments\n    this.header = new JOSEHeader(data.header)\n    this.protected = data.protected\n    this.unprotected = data.unprotected\n    this.iv = data.iv\n    this.aad = data.aad\n    this.ciphertext = data.ciphertext\n    this.tag = data.tag\n    this.recipients = data.recipients\n    this.payload = data.payload\n    this.signatures = data.signatures\n    this.signature = data.signature\n    this.key = data.key\n    this.serialization = data.serialization || 'compact' // default\n  }\n\n  /**\n   * decode\n   *\n   * @description\n   * Decode a JSON Web Token\n   *\n   * @param {string} data\n   * @returns {JWT}\n   */\n  static decode (data) {\n    let ExtendedJWT = this\n    let jwt\n\n    if (typeof data !== 'string') {\n      throw new DataError('JWT must be a string')\n    }\n\n    // JSON of Flattened JSON Serialization\n    if (data.startsWith('{')) {\n      try {\n        data = JSON.parse(data, () => {})\n      } catch (error) {\n        throw new DataError('Invalid JWT serialization')\n      }\n\n      if (data.signatures || data.recipients) {\n        data.serialization = 'json'\n      } else {\n        data.serialization = 'flattened'\n      }\n\n      jwt = new ExtendedJWT(data, { filter: false })\n\n    // Compact Serialization\n    } else {\n      try {\n        let serialization = 'compact'\n        let segments = data.split('.')\n        let length = segments.length\n\n        if (length !== 3 && length !== 5) {\n          throw new Error('Malformed JWT')\n        }\n\n        let header = JSON.parse(base64url.decode(segments[0]))\n\n        // JSON Web Signature\n        if (length === 3) {\n          let type = 'JWS'\n          let payload = JSON.parse(base64url.decode(segments[1]))\n          let signature = segments[2]\n\n          jwt = new ExtendedJWT(\n              { type, segments, header, payload, signature, serialization },\n              { filter: false }\n            )\n        }\n\n        // JSON Web Encryption\n        if (length === 5) {\n          //let type = 'JWE'\n          //let [protected, encryption_key, iv, ciphertext, tag] = segments\n\n          //jwt = new ExtendedJWT({\n          //  type,\n          //  protected: base64url.decode(JSON.parse(protected)),\n          //  encryption_key,\n          //  iv,\n          //  ciphertext,\n          //  tag,\n          //  serialization\n          //})\n        }\n      } catch (error) {\n        throw new DataError('Invalid JWT compact serialization')\n      }\n    }\n\n    return jwt\n  }\n\n  /**\n   * encode\n   *\n   * @description\n   * Encode a JSON Web Token\n   *\n   * @param {Object} header\n   * @param {Object} payload\n   * @param {CryptoKey} key\n   *\n   * @returns {Promise}\n   */\n  static encode (header, payload, key) {\n    let jwt = new JWT(header, payload)\n    return jwt.encode(key)\n  }\n\n\n  /**\n   * verify\n   *\n   * @description\n   *\n   * @param {CryptoKey} key\n   * @param {string} token\n   *\n   * @returns {Promise}\n   */\n  static async verify (key, token) {\n    let jwt = JWT.decode(token)\n    jwt.key = key\n    return jwt.verify().then(verified => jwt)\n  }\n\n  /**\n   * isJWE\n   */\n  isJWE () {\n    return !!this.header.enc\n  }\n\n  /**\n   * resolveKeys\n   */\n  resolveKeys (jwks) {\n    let kid = this.header.kid\n    let keys, match\n\n    // treat an array as the \"keys\" property of a JWK Set\n    if (Array.isArray(jwks)) {\n      keys = jwks\n    }\n\n    // presence of keys indicates object is a JWK Set\n    if (jwks.keys) {\n      keys = jwks.keys\n    }\n\n    // wrap a plain object they is not a JWK Set in Array\n    if (!jwks.keys && typeof jwks === 'object') {\n      keys = [jwks]\n    }\n\n    // ensure there are keys to search\n    if (!keys) {\n      throw new DataError('Invalid JWK argument')\n    }\n\n    // match by \"kid\" or \"use\" header\n    if (kid) {\n      match = keys.find(jwk => jwk.kid === kid)\n    } else {\n      match = keys.find(jwk => jwk.use === 'sig')\n    }\n\n    // assign matching key to JWT and return a boolean\n    if (match) {\n      this.key = match.cryptoKey\n      return true\n    } else {\n      return false\n    }\n  }\n\n  /**\n   * encode\n   *\n   * @description\n   * Encode a JWT instance\n   *\n   * @returns {Promise}\n   */\n  async encode () {\n    let token = this\n\n    if (this.isJWE()) {\n      return JWE.encrypt(token)\n    } else {\n      return JWS.sign(token)\n    }\n  }\n\n  /**\n   * verify\n   *\n   * @description\n   * Verify a decoded JWT instance\n   *\n   * @returns {Promise}\n   */\n  async verify () {\n    return JWS.verify(this)\n  }\n}\n\n/**\n * Export\n */\nmodule.exports = JWT\n","const TextEncoder = global.TextEncoder\n  ? global.TextEncoder  // browser\n  : require('@sinonjs/text-encoding').TextEncoder  // node shim\nmodule.exports = TextEncoder\n","module.exports = TextEncoder;","module.exports = crypto;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(138);\n"],"names":["pad_string_1","encode","input","encoding","Buffer","isBuffer","fromBase64","toString","from","toBase64","base64url","default","replace","base64","decode","toBuffer","exports","Object","defineProperty","value","stringLength","length","diff","position","padLength","paddedStringLength","buffer","alloc","write","module","crypto","TextEncoder","constructor","params","this","sign","key","data","algorithm","subtle","then","signature","verify","Uint8Array","assertSufficientKeyLength","bitlength","Error","async","jwk","assign","usages","use","push","Promise","resolve","key_ops","importKey","cryptoKey","enumerable","NotSupportedError","operations","forEach","op","define","alg","argument","normalize","registeredAlgorithms","SyntaxError","None","HMAC","RSASSA_PKCS1_v1_5","ECDSA","supportedAlgorithms","name","hash","namedCurve","imported","DataError","message","super","JWA","JWK","JWKSet","JWT","JWS","typ","cty","jku","kid","x5u","x5c","x5t","crit","enc","zip","isJWS","isJWE","static","normalizedAlgorithm","reject","kty","keys","jwks","importing","map","err","all","JOSEHeader","header","payload","protected","signatures","verified","token","JSON","stringify","serialization","jwt","segments","type","unprotected","iv","aad","ciphertext","tag","recipients","ExtendedJWT","startsWith","parse","error","filter","split","resolveKeys","match","Array","isArray","find","JWE","encrypt","g","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","globalThis","Function","e","window","__webpack_exports__"],"sourceRoot":""}