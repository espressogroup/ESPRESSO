var JOSE;(()=>{var e={240:(e,t,r)=>{"use strict";var s=r(518);function n(e,t){return void 0===t&&(t="utf8"),Buffer.isBuffer(e)?a(e.toString("base64")):a(Buffer.from(e,t).toString("base64"))}function i(e){return e=e.toString(),s.default(e).replace(/\-/g,"+").replace(/_/g,"/")}function a(e){return e.replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_")}var o=n;o.encode=n,o.decode=function(e,t){return void 0===t&&(t="utf8"),Buffer.from(i(e),"base64").toString(t)},o.toBase64=i,o.fromBase64=a,o.toBuffer=function(e){return Buffer.from(i(e),"base64")},t.default=o},518:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){var t=e.length,r=t%4;if(!r)return e;var s=t,n=4-r,i=t+n,a=Buffer.alloc(i);for(a.write(e);n--;)a.write("=",s++);return a.toString()}},772:(e,t,r)=>{e.exports=r(240).default,e.exports.default=e.exports},884:(e,t,r)=>{"use strict";const s=r(772),n=r(876),i=r(930);e.exports=class{constructor(e){this.params=e}sign(e,t){let r=this.params;return t=(new i).encode(t),n.subtle.sign(r,e,t).then((e=>s(Buffer.from(e))))}verify(e,t,r){let a=this.params;return"string"==typeof t&&(t=Uint8Array.from(s.toBuffer(t))),"string"==typeof r&&(r=(new i).encode(r)),n.subtle.verify(a,e,t,r)}assertSufficientKeyLength(e){if(e.length<this.bitlength)throw new Error("The key is too short.")}async importKey(e){let t=Object.assign({},e),r=this.params,s=e.key_ops||[];return"sig"===e.use&&s.push("verify"),"enc"===e.use?Promise.resolve(e):(e.key_ops&&(s=e.key_ops),n.subtle.importKey("jwk",t,r,!0,s).then((e=>(Object.defineProperty(t,"cryptoKey",{enumerable:!1,value:e}),t))))}}},379:(e,t,r)=>{"use strict";const s=r(772),n=r(876),i=r(930);e.exports=class{constructor(e){this.params=e}sign(e,t){let r=this.params;return t=(new i).encode(t),n.subtle.sign(r,e,t).then((e=>s(Buffer.from(e))))}verify(e,t,r){let a=this.params;return"string"==typeof t&&(t=Uint8Array.from(s.toBuffer(t))),"string"==typeof r&&(r=(new i).encode(r)),n.subtle.verify(a,e,t,r)}assertSufficientKeyLength(e){if(e.length<this.bitlength)throw new Error("The key is too short.")}}},289:e=>{e.exports=class{sign(){return Promise.resolve("")}verify(){}}},221:(e,t,r)=>{"use strict";const s=r(772);let n=r(473);const i=r(930);e.exports=class{constructor(e){this.params=e}sign(e,t){let r=this.params;return t=(new i).encode(t),n.subtle.sign(r,e,t).then((e=>s(Buffer.from(e))))}verify(e,t,r){let a=this.params;return"string"==typeof t&&(t=Uint8Array.from(s.toBuffer(t))),"string"==typeof r&&(r=(new i).encode(r)),n.subtle.verify(a,e,t,r)}async importKey(e){let t=Object.assign({},e),r=this.params,s=e.key_ops||[];return"sig"===e.use&&s.push("verify"),"enc"===e.use?Promise.resolve(e):(e.key_ops&&(s=e.key_ops),n.subtle.importKey("jwk",t,r,!0,s).then((e=>(Object.defineProperty(t,"cryptoKey",{enumerable:!1,value:e}),t))))}}},533:(e,t,r)=>{const s=r(754),n=["sign","verify","encrypt","decrypt","importKey"];e.exports=class{constructor(){n.forEach((e=>{this[e]={}}))}static get operations(){return n}define(e,t,r){this[t][e]=r}normalize(e,t){let r=this[e];return r?r[t]||new s(t):new SyntaxError}}},586:(e,t,r)=>{const s=r(289),n=r(379),i=r(221),a=r(884),o=new(r(533));o.define("HS256","sign",new n({name:"HMAC",hash:{name:"SHA-256"}})),o.define("HS384","sign",new n({name:"HMAC",hash:{name:"SHA-384"}})),o.define("HS512","sign",new n({name:"HMAC",hash:{name:"SHA-512"}})),o.define("RS256","sign",new i({name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}})),o.define("RS384","sign",new i({name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-384"}})),o.define("RS512","sign",new i({name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-512"}})),o.define("ES256","sign",new a({name:"ECDSA",hash:{name:"SHA-256"},namedCurve:"P-256"})),o.define("none","sign",new s({})),o.define("HS256","verify",new n({name:"HMAC",hash:{name:"SHA-256"}})),o.define("HS384","verify",new n({name:"HMAC",hash:{name:"SHA-384"}})),o.define("HS512","verify",new n({name:"HMAC",hash:{name:"SHA-512"}})),o.define("RS256","verify",new i({name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}})),o.define("RS384","verify",new i({name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-384"}})),o.define("RS512","verify",new i({name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-512"}})),o.define("ES256","verify",new a({name:"ECDSA",hash:{name:"SHA-256"},namedCurve:"P-256"})),o.define("none","verify",new s({})),o.define("RS256","importKey",new i({name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}})),o.define("RS384","importKey",new i({name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-384"}})),o.define("RS512","importKey",new i({name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-512"}})),o.define("ES256","importKey",new a({name:"ECDSA",hash:{name:"SHA-256"},namedCurve:"P-256"})),e.exports=o},473:(e,t,r)=>{const s=r(876);e.exports=s.default?s.default:s},683:e=>{class t extends Error{constructor(e){super(e)}}e.exports=t},754:e=>{class t extends Error{constructor(e){super(),this.message=`${e} is not a supported algorithm`}}e.exports=t},166:(e,t,r)=>{e.exports={DataError:r(683),NotSupportedError:r(754)}},138:(e,t,r)=>{const s=r(473),n=r(251),i=r(507),a=r(20),o=r(570),c=r(574);e.exports={crypto:s,JWA:n,JWK:i,JWKSet:a,JWT:o,JWS:c}},59:e=>{e.exports=class{constructor({typ:e,cty:t,alg:r,jku:s,kid:n,x5u:i,x5c:a,x5t:o,crit:c,enc:h,zip:u}={}){this.typ=e,this.cty=t,this.alg=r,this.jku=s,this.kid=n,this.x5u=i,this.x5c=a,this.x5t=o,this.crit=c,this.enc=h,this.zip=u}isJWS(){}isJWE(){}}},251:(e,t,r)=>{const s=r(586),{NotSupportedError:n}=r(166);e.exports=class{static async sign(e,t,r){let i=s.normalize("sign",e);return i instanceof Error?Promise.reject(new n(e)):i.sign(t,r)}static async verify(e,t,r,i){let a=s.normalize("verify",e);return a instanceof Error?Promise.reject(new n(e)):a.verify(t,r,i)}static async importKey(e){return s.normalize("importKey",e.alg).importKey(e)}}},507:(e,t,r)=>{"use strict";const s=r(251);e.exports=class{constructor({kty:e,use:t,key_ops:r,alg:s,kid:n,x5u:i,x5c:a,x5t:o}={}){this.kty=e,this.use=t,this.key_ops=r,this.alg=s,this.kid=n,this.x5u=i,this.x5c=a,this.x5t=o}static async importKey(e){return s.importKey(e)}}},20:(e,t,r)=>{"use strict";const s=r(507);class n{constructor({keys:e}={}){this.keys=e}static async importKeys(e){if(!e.keys)return Promise.reject(new Error("Cannot import JWKSet: keys property is empty"));let t,r;try{t=new n(e),r=e.keys.map((e=>s.importKey(e)))}catch(e){return Promise.reject(e)}return Promise.all(r).then((e=>(t.keys=e,t)))}}e.exports=n},574:(e,t,r)=>{const s=r(772),n=r(251),{DataError:i}=r(166),a=r(59);e.exports=class{constructor(e={}){this.header=new a(e.header),this.payload=e.payload||{},this.signature=e.signature,this.protected=e.protected,this.signatures=e.signatures,this.verified=!1}static async sign(e){let t=s(JSON.stringify(e.payload));if("compact"===e.serialization){let{key:r,header:{alg:i}}=e,a=`${s(JSON.stringify(e.header))}.${t}`;return n.sign(i,r,a).then((e=>`${a}.${e}`))}return e.serialization,e.serialization,Promise.reject(new i("Unsupported serialization"))}static async verify(e){e.signatures;let{key:t,signature:r,header:{alg:s}}=e;if(e.signature){let[a,o]=e.segments,c=`${a}.${o}`;return"none"===s?Promise.reject(new i("Signature provided to verify with alg: none")):n.verify(s,t,r,c).then((t=>(e.verified=t,t)))}if("none"===s){if(!t&&!r)return e.verified=!0,Promise.resolve(!0);if(t)return Promise.reject(new i("Key provided to verify signature with alg: none"))}return Promise.reject(new i("Missing signature(s)"))}}},570:(e,t,r)=>{const s=r(772),n=r(574),i=r(683),a=r(59);class o{constructor(e={}){this.type=e.type,this.segments=e.segments,this.header=new a(e.header),this.protected=e.protected,this.unprotected=e.unprotected,this.iv=e.iv,this.aad=e.aad,this.ciphertext=e.ciphertext,this.tag=e.tag,this.recipients=e.recipients,this.payload=e.payload,this.signatures=e.signatures,this.signature=e.signature,this.key=e.key,this.serialization=e.serialization||"compact"}static decode(e){let t,r=this;if("string"!=typeof e)throw new i("JWT must be a string");if(e.startsWith("{")){try{e=JSON.parse(e,(()=>{}))}catch(e){throw new i("Invalid JWT serialization")}e.signatures||e.recipients?e.serialization="json":e.serialization="flattened",t=new r(e,{filter:!1})}else try{let n="compact",i=e.split("."),a=i.length;if(3!==a&&5!==a)throw new Error("Malformed JWT");let o=JSON.parse(s.decode(i[0]));3===a&&(t=new r({type:"JWS",segments:i,header:o,payload:JSON.parse(s.decode(i[1])),signature:i[2],serialization:n},{filter:!1}))}catch(e){throw new i("Invalid JWT compact serialization")}return t}static encode(e,t,r){return new o(e,t).encode(r)}static async verify(e,t){let r=o.decode(t);return r.key=e,r.verify().then((e=>r))}isJWE(){return!!this.header.enc}resolveKeys(e){let t,r,s=this.header.kid;if(Array.isArray(e)&&(t=e),e.keys&&(t=e.keys),e.keys||"object"!=typeof e||(t=[e]),!t)throw new i("Invalid JWK argument");return r=s?t.find((e=>e.kid===s)):t.find((e=>"sig"===e.use)),!!r&&(this.key=r.cryptoKey,!0)}async encode(){return this.isJWE()?JWE.encrypt(this):n.sign(this)}async verify(){return n.verify(this)}}e.exports=o},930:(e,t,r)=>{const s=r.g.TextEncoder?r.g.TextEncoder:r(875).TextEncoder;e.exports=s},875:e=>{"use strict";e.exports=TextEncoder},876:e=>{"use strict";e.exports=crypto}},t={};function r(s){var n=t[s];if(void 0!==n)return n.exports;var i=t[s]={exports:{}};return e[s](i,i.exports,r),i.exports}r.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}();var s=r(138);JOSE=s})();
//# sourceMappingURL=jose.min.js.map