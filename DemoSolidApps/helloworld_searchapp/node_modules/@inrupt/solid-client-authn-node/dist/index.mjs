import { StorageUtility, ClientAuthentication as ClientAuthentication$1, isValidRedirectUrl, ConfigurationError, handleRegistration, AggregateHandler, AuthorizationCodeWithPkceOidcHandlerBase, DEFAULT_SCOPES, PREFERRED_SIGNING_ALG, getWebidFromTokenPayload, saveSessionInfoToStorage, generateDpopKeyPair, buildAuthenticatedFetch, SOLID_CLIENT_AUTHN_KEY_PREFIX, SessionInfoManagerBase, getSessionIdFromOauthState, loadOidcContextFromStorage, removeOpenIdParams, EVENTS, maybeBuildRpInitiatedLogout, getUnauthenticatedSession, isKnownClientType, determineSigningAlg, InMemoryStorage, IWaterfallLogoutHandler } from '@inrupt/solid-client-authn-core';
export { ConfigurationError, EVENTS, InMemoryStorage, NotImplementedError } from '@inrupt/solid-client-authn-core';
import { v4 } from 'uuid';
import EventEmitter from 'events';
import { Issuer, generators } from 'openid-client';
import { importJWK } from 'jose';
import { URL } from 'url';

//
// Copyright Inrupt Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
// Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
/**
 * This class in a no-value-added extension of StorageUtility from the core module.
 * The reason it has to be declared is for TSyringe to find the decorators in the
 * same modules as where the dependency container is declared (in this case,
 * the browser module, with the dependancy container in dependencies.ts).
 * @hidden
 */
class StorageUtilityNode extends StorageUtility {
    constructor(secureStorage, insecureStorage) {
        super(secureStorage, insecureStorage);
    }
}

//
// Copyright Inrupt Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
// Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
/**
 * @hidden
 * @packageDocumentation
 */
/**
 * @hidden
 */
class ClientAuthentication extends ClientAuthentication$1 {
    constructor() {
        super(...arguments);
        // Define these functions as properties so that they don't get accidentally re-bound.
        // Isn't Javascript fun?
        this.login = async (sessionId, options, eventEmitter) => {
            var _a, _b;
            // Keep track of the session ID
            await this.sessionInfoManager.register(sessionId);
            if (typeof options.redirectUrl === "string" &&
                !isValidRedirectUrl(options.redirectUrl)) {
                throw new Error(`${options.redirectUrl} is not a valid redirect URL, it is either a malformed IRI, includes a hash fragment, or reserved query parameters ('code' or 'state').`);
            }
            const loginReturn = await this.loginHandler.handle({
                sessionId,
                oidcIssuer: options.oidcIssuer,
                redirectUrl: options.redirectUrl,
                clientId: options.clientId,
                clientSecret: options.clientSecret,
                clientName: (_a = options.clientName) !== null && _a !== void 0 ? _a : options.clientId,
                refreshToken: options.refreshToken,
                handleRedirect: options.handleRedirect,
                // Defaults to DPoP
                tokenType: (_b = options.tokenType) !== null && _b !== void 0 ? _b : "DPoP",
                eventEmitter,
            });
            if (loginReturn !== undefined) {
                this.fetch = loginReturn.fetch;
                return loginReturn;
            }
            // undefined is returned in the case when the login must be completed
            // after redirect.
            return undefined;
        };
        this.getSessionIdAll = async () => {
            return this.sessionInfoManager.getRegisteredSessionIdAll();
        };
        this.registerSession = async (sessionId) => {
            return this.sessionInfoManager.register(sessionId);
        };
        this.clearSessionAll = async () => {
            return this.sessionInfoManager.clearAll();
        };
        this.handleIncomingRedirect = async (url, eventEmitter) => {
            const redirectInfo = await this.redirectHandler.handle(url, eventEmitter);
            this.fetch = redirectInfo.fetch;
            this.boundLogout = redirectInfo.getLogoutUrl;
            return {
                isLoggedIn: redirectInfo.isLoggedIn,
                webId: redirectInfo.webId,
                sessionId: redirectInfo.sessionId,
            };
        };
    }
}

//
// Copyright Inrupt Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
// Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
function hasIssuer(options) {
    return typeof options.oidcIssuer === "string";
}
// TODO: the following code must be pushed to the handlers that actually need redirection
// function hasRedirectUrl(
//   options: ILoginOptions
// ): options is ILoginOptions & { redirectUrl: string } {
//   return typeof options.redirectUrl === "string";
// }
/**
 * @hidden
 */
class OidcLoginHandler {
    constructor(storageUtility, oidcHandler, issuerConfigFetcher, clientRegistrar) {
        this.storageUtility = storageUtility;
        this.oidcHandler = oidcHandler;
        this.issuerConfigFetcher = issuerConfigFetcher;
        this.clientRegistrar = clientRegistrar;
        this.storageUtility = storageUtility;
        this.oidcHandler = oidcHandler;
        this.issuerConfigFetcher = issuerConfigFetcher;
        this.clientRegistrar = clientRegistrar;
    }
    async canHandle(options) {
        return hasIssuer(options);
    }
    async handle(options) {
        var _a;
        if (!hasIssuer(options)) {
            throw new ConfigurationError(`OidcLoginHandler requires an OIDC issuer: missing property 'oidcIssuer' in ${JSON.stringify(options)}`);
        }
        // TODO: the following code must be pushed to the handlers that actually need redirection
        // if (!hasRedirectUrl(options)) {
        //   throw new ConfigurationError(
        //     `OidcLoginHandler requires a redirect URL: missing property 'redirectUrl' in ${JSON.stringify(
        //       options
        //     )}`
        //   );
        // }
        const issuerConfig = await this.issuerConfigFetcher.fetchConfig(options.oidcIssuer);
        const clientInfo = await handleRegistration(options, issuerConfig, this.storageUtility, this.clientRegistrar);
        // Construct OIDC Options
        const oidcOptions = {
            issuer: issuerConfig.issuer,
            // TODO: differentiate if DPoP should be true
            dpop: options.tokenType.toLowerCase() === "dpop",
            redirectUrl: options.redirectUrl,
            issuerConfiguration: issuerConfig,
            client: clientInfo,
            sessionId: options.sessionId,
            // If the refresh token is available in storage, use it.
            refreshToken: (_a = options.refreshToken) !== null && _a !== void 0 ? _a : (await this.storageUtility.getForUser(options.sessionId, "refreshToken")),
            handleRedirect: options.handleRedirect,
            eventEmitter: options.eventEmitter,
        };
        // Call proper OIDC Handler
        return this.oidcHandler.handle(oidcOptions);
    }
}

//
// Copyright Inrupt Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
// Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
/**
 * @hidden
 */
class AggregateOidcHandler extends AggregateHandler {
    constructor(oidcLoginHandlers) {
        super(oidcLoginHandlers);
    }
}

//
// Copyright Inrupt Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
// Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
/**
 * Transforms an openid-client IssuerMetadata object into an [[IIssuerConfig]]
 * @param metadata the object to transform.
 * @returns an [[IIssuerConfig]] initialized from the metadata.
 * @internal
 */
function configFromIssuerMetadata(metadata) {
    // If the fields required as per https://openid.net/specs/openid-connect-discovery-1_0.html are missing,
    // throw an error.
    if (metadata.authorization_endpoint === undefined) {
        throw new ConfigurationError(`Issuer metadata is missing an authorization endpoint: ${JSON.stringify(metadata)}`);
    }
    if (metadata.token_endpoint === undefined) {
        throw new ConfigurationError(`Issuer metadata is missing an token endpoint: ${JSON.stringify(metadata)}`);
    }
    if (metadata.jwks_uri === undefined) {
        throw new ConfigurationError(`Issuer metadata is missing a keyset URI: ${JSON.stringify(metadata)}`);
    }
    if (metadata.claims_supported === undefined) {
        throw new ConfigurationError(`Issuer metadata is missing supported claims: ${JSON.stringify(metadata)}`);
    }
    if (metadata.subject_types_supported === undefined) {
        throw new ConfigurationError(`Issuer metadata is missing supported subject types: ${JSON.stringify(metadata)}`);
    }
    return {
        issuer: metadata.issuer,
        authorizationEndpoint: metadata.authorization_endpoint,
        subjectTypesSupported: metadata.subject_types_supported,
        claimsSupported: metadata.claims_supported,
        tokenEndpoint: metadata.token_endpoint,
        jwksUri: metadata.jwks_uri,
        userinfoEndpoint: metadata.userinfo_endpoint,
        registrationEndpoint: metadata.registration_endpoint,
        tokenEndpointAuthMethodsSupported: metadata.token_endpoint_auth_methods_supported,
        tokenEndpointAuthSigningAlgValuesSupported: metadata.token_endpoint_auth_signing_alg_values_supported,
        requestObjectSigningAlgValuesSupported: metadata.request_object_signing_alg_values_supported,
        // TODO: add revocation_endpoint, end_session_endpoint, introspection_endpoint_auth_methods_supported, introspection_endpoint_auth_signing_alg_values_supported, revocation_endpoint_auth_methods_supported, revocation_endpoint_auth_signing_alg_values_supported, mtls_endpoint_aliases to IIssuerConfig
        // The following properties may be captured as "unkown" entries in the metadata object.
        grantTypesSupported: metadata.grant_types_supported,
        responseTypesSupported: metadata.response_types_supported,
        idTokenSigningAlgValuesSupported: metadata.id_token_signing_alg_values_supported,
        scopesSupported: metadata.scopes_supported === undefined
            ? ["openid"]
            : metadata.scopes_supported,
        endSessionEndpoint: metadata.end_session_endpoint,
    };
}
/**
 * Transforms an [[IIssuerConfig]] into an openid-client IssuerMetadata
 * @param config the IIssuerConfig to convert.
 * @returns an IssuerMetadata object initialized from the [[IIssuerConfig]].
 */
function configToIssuerMetadata(config) {
    return {
        issuer: config.issuer,
        authorization_endpoint: config.authorizationEndpoint,
        jwks_uri: config.jwksUri,
        token_endpoint: config.tokenEndpoint,
        registration_endpoint: config.registrationEndpoint,
        subject_types_supported: config.subjectTypesSupported,
        claims_supported: config.claimsSupported,
        token_endpoint_auth_signing_alg_values_supported: config.tokenEndpointAuthSigningAlgValuesSupported,
        userinfo_endpoint: config.userinfoEndpoint,
        token_endpoint_auth_methods_supported: config.tokenEndpointAuthMethodsSupported,
        request_object_signing_alg_values_supported: config.requestObjectSigningAlgValuesSupported,
        grant_types_supported: config.grantTypesSupported,
        response_types_supported: config.responseTypesSupported,
        id_token_signing_alg_values_supported: config.idTokenSigningAlgValuesSupported,
        scopes_supported: config.scopesSupported,
        end_session_endpoint: config.endSessionEndpoint,
    };
}
/**
 * @hidden
 */
class IssuerConfigFetcher {
    constructor(storageUtility) {
        this.storageUtility = storageUtility;
        this.storageUtility = storageUtility;
    }
    // This method needs no state (so can be static), and can be exposed to allow
    // callers to know where this implementation puts state it needs.
    static getLocalStorageKey(issuer) {
        return `issuerConfig:${issuer}`;
    }
    async fetchConfig(issuer) {
        // TODO: The issuer config discovery happens in multiple places in the current
        // codebase, because in openid-client the Client is built based on the Issuer.
        // The codebase could be refactored so that issuer discovery only happens once.
        const oidcIssuer = await Issuer.discover(issuer);
        const issuerConfig = configFromIssuerMetadata(oidcIssuer.metadata);
        // Update store with fetched config
        await this.storageUtility.set(IssuerConfigFetcher.getLocalStorageKey(issuer), JSON.stringify(issuerConfig));
        return issuerConfig;
    }
}

//
// Copyright Inrupt Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
// Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
/**
 * @hidden
 * Authorization code flow spec: https://openid.net/specs/openid-connect-core-1_0.html#CodeFlowAuth
 * PKCE: https://tools.ietf.org/html/rfc7636
 */
class AuthorizationCodeWithPkceOidcHandler extends AuthorizationCodeWithPkceOidcHandlerBase {
    async handle(oidcLoginOptions) {
        const issuer = new Issuer(configToIssuerMetadata(oidcLoginOptions.issuerConfiguration));
        const client = new issuer.Client({
            client_id: oidcLoginOptions.client.clientId,
        });
        const codeVerifier = generators.codeVerifier();
        const state = generators.state();
        const targetUrl = client.authorizationUrl({
            code_challenge: generators.codeChallenge(codeVerifier),
            state,
            response_type: "code",
            redirect_uri: oidcLoginOptions.redirectUrl,
            code_challenge_method: "S256",
            prompt: "consent",
            scope: DEFAULT_SCOPES,
        });
        return this.handleRedirect({
            oidcLoginOptions,
            state,
            codeVerifier,
            targetUrl,
        });
    }
}

//
// Copyright Inrupt Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
// Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
function validateOptions(oidcLoginOptions) {
    return (oidcLoginOptions.refreshToken !== undefined &&
        oidcLoginOptions.client.clientId !== undefined);
}
/**
 * Go through the refresh flow to get a new valid access token, and build an
 * authenticated fetch with it.
 * @param refreshOptions
 * @param dpop
 */
async function refreshAccess(refreshOptions, dpop, refreshBindingKey, eventEmitter) {
    var _a;
    try {
        let dpopKey;
        if (dpop) {
            dpopKey = refreshBindingKey || (await generateDpopKeyPair());
            // The alg property isn't set by exportJWK, so set it manually.
            [dpopKey.publicKey.alg] = PREFERRED_SIGNING_ALG;
        }
        const tokens = await refreshOptions.tokenRefresher.refresh(refreshOptions.sessionId, refreshOptions.refreshToken, dpopKey);
        // Rotate the refresh token if applicable
        const rotatedRefreshOptions = {
            ...refreshOptions,
            refreshToken: (_a = tokens.refreshToken) !== null && _a !== void 0 ? _a : refreshOptions.refreshToken,
        };
        const authFetch = await buildAuthenticatedFetch(tokens.accessToken, {
            dpopKey,
            refreshOptions: rotatedRefreshOptions,
            eventEmitter,
        });
        return Object.assign(tokens, {
            fetch: authFetch,
        });
    }
    catch (e) {
        throw new Error(`Invalid refresh credentials: ${e}`);
    }
}
/**
 * @hidden
 * Refresh token flow spec: https://openid.net/specs/openid-connect-core-1_0.html#RefreshTokens
 */
class RefreshTokenOidcHandler {
    constructor(tokenRefresher, storageUtility) {
        this.tokenRefresher = tokenRefresher;
        this.storageUtility = storageUtility;
        this.tokenRefresher = tokenRefresher;
        this.storageUtility = storageUtility;
    }
    async canHandle(oidcLoginOptions) {
        return validateOptions(oidcLoginOptions);
    }
    async handle(oidcLoginOptions) {
        var _a;
        if (!validateOptions(oidcLoginOptions)) {
            throw new Error(`RefreshTokenOidcHandler cannot handle the provided options, missing one of 'refreshToken', 'clientId' in: ${JSON.stringify(oidcLoginOptions)}`);
        }
        const refreshOptions = {
            refreshToken: oidcLoginOptions.refreshToken,
            sessionId: oidcLoginOptions.sessionId,
            tokenRefresher: this.tokenRefresher,
        };
        const dataToStore = {
            issuer: oidcLoginOptions.issuer,
            dpop: oidcLoginOptions.dpop ? "true" : "false",
            clientId: oidcLoginOptions.client.clientId,
        };
        if (typeof oidcLoginOptions.client.clientSecret === "string") {
            dataToStore.clientSecret = oidcLoginOptions.client.clientSecret;
        }
        if (typeof oidcLoginOptions.client.clientName === "string") {
            dataToStore.clientName = oidcLoginOptions.client.clientName;
        }
        // This information must be in storage for the refresh flow to succeed.
        await this.storageUtility.setForUser(oidcLoginOptions.sessionId, dataToStore);
        // In the case when the refresh token is bound to a DPoP key, said key must
        // be used during the refresh grant.
        const publicKey = await this.storageUtility.getForUser(oidcLoginOptions.sessionId, "publicKey");
        const privateKey = await this.storageUtility.getForUser(oidcLoginOptions.sessionId, "privateKey");
        let keyPair;
        if (publicKey !== undefined && privateKey !== undefined) {
            keyPair = {
                publicKey: JSON.parse(publicKey),
                privateKey: (await importJWK(JSON.parse(privateKey), PREFERRED_SIGNING_ALG[0])),
            };
        }
        const accessInfo = await refreshAccess(refreshOptions, oidcLoginOptions.dpop, keyPair);
        const sessionInfo = {
            isLoggedIn: true,
            sessionId: oidcLoginOptions.sessionId,
        };
        if (accessInfo.idToken === undefined) {
            throw new Error(`The Identity Provider [${oidcLoginOptions.issuer}] did not return an ID token on refresh, which prevents us from getting the user's WebID.`);
        }
        sessionInfo.webId = await getWebidFromTokenPayload(accessInfo.idToken, oidcLoginOptions.issuerConfiguration.jwksUri, oidcLoginOptions.issuer, oidcLoginOptions.client.clientId);
        await saveSessionInfoToStorage(this.storageUtility, oidcLoginOptions.sessionId, undefined, "true", (_a = accessInfo.refreshToken) !== null && _a !== void 0 ? _a : refreshOptions.refreshToken, undefined, keyPair);
        let expirationDate;
        expirationDate = accessInfo.expiresAt;
        if (expirationDate === undefined && accessInfo.expiresIn !== undefined) {
            expirationDate = accessInfo.expiresIn + Date.now();
        }
        sessionInfo.expirationDate = expirationDate;
        return Object.assign(sessionInfo, {
            fetch: accessInfo.fetch,
        });
    }
}

//
// Copyright Inrupt Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
// Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
const KEY_REGISTERED_SESSIONS = `${SOLID_CLIENT_AUTHN_KEY_PREFIX}registeredSessions`;

//
// Copyright Inrupt Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
// Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
/**
 * @hidden
 */
class SessionInfoManager extends SessionInfoManagerBase {
    async get(sessionId) {
        const webId = await this.storageUtility.getForUser(sessionId, "webId");
        const isLoggedIn = await this.storageUtility.getForUser(sessionId, "isLoggedIn");
        const refreshToken = await this.storageUtility.getForUser(sessionId, "refreshToken");
        const issuer = await this.storageUtility.getForUser(sessionId, "issuer");
        if (issuer !== undefined) {
            return {
                sessionId,
                webId,
                isLoggedIn: isLoggedIn === "true",
                refreshToken,
                issuer,
            };
        }
        return undefined;
    }
    /**
     * This function removes all session-related information from storage.
     * @param sessionId the session identifier
     * @param storage the storage where session info is stored
     * @hidden
     */
    async clear(sessionId) {
        const rawSessions = await this.storageUtility.get(KEY_REGISTERED_SESSIONS);
        if (rawSessions !== undefined) {
            const sessions = JSON.parse(rawSessions);
            await this.storageUtility.set(KEY_REGISTERED_SESSIONS, JSON.stringify(sessions.filter((storedSessionId) => storedSessionId !== sessionId)));
        }
        return super.clear(sessionId);
    }
    /**
     * Registers a new session, so that its ID can be retrieved.
     * @param sessionId
     */
    async register(sessionId) {
        const rawSessions = await this.storageUtility.get(KEY_REGISTERED_SESSIONS);
        if (rawSessions === undefined) {
            return this.storageUtility.set(KEY_REGISTERED_SESSIONS, JSON.stringify([sessionId]));
        }
        const sessions = JSON.parse(rawSessions);
        if (!sessions.includes(sessionId)) {
            sessions.push(sessionId);
            return this.storageUtility.set(KEY_REGISTERED_SESSIONS, JSON.stringify(sessions));
        }
        return Promise.resolve();
    }
    /**
     * Returns all the registered session IDs. Differs from getAll, which also
     * returns additional session information.
     */
    async getRegisteredSessionIdAll() {
        return this.storageUtility.get(KEY_REGISTERED_SESSIONS).then((data) => {
            if (data === undefined) {
                return [];
            }
            return JSON.parse(data);
        });
    }
    /**
     * Deletes all information about all sessions, including their registrations.
     */
    async clearAll() {
        const rawSessions = await this.storageUtility.get(KEY_REGISTERED_SESSIONS);
        if (rawSessions === undefined) {
            return Promise.resolve();
        }
        const sessions = JSON.parse(rawSessions);
        await Promise.all(sessions.map((sessionId) => this.clear(sessionId)));
        return this.storageUtility.set(KEY_REGISTERED_SESSIONS, JSON.stringify([]));
    }
}

//
// Copyright Inrupt Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
// Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
/**
 * @hidden
 * Token endpoint request: https://openid.net/specs/openid-connect-core-1_0.html#TokenEndpoint
 */
class AuthCodeRedirectHandler {
    constructor(storageUtility, sessionInfoManager, issuerConfigFetcher, clientRegistrar, tokenRefresher) {
        this.storageUtility = storageUtility;
        this.sessionInfoManager = sessionInfoManager;
        this.issuerConfigFetcher = issuerConfigFetcher;
        this.clientRegistrar = clientRegistrar;
        this.tokenRefresher = tokenRefresher;
        this.storageUtility = storageUtility;
        this.sessionInfoManager = sessionInfoManager;
        this.issuerConfigFetcher = issuerConfigFetcher;
        this.clientRegistrar = clientRegistrar;
        this.tokenRefresher = tokenRefresher;
    }
    async canHandle(redirectUrl) {
        try {
            const myUrl = new URL(redirectUrl);
            return (myUrl.searchParams.get("code") !== null &&
                myUrl.searchParams.get("state") !== null);
        }
        catch (e) {
            throw new Error(`[${redirectUrl}] is not a valid URL, and cannot be used as a redirect URL: ${e}`);
        }
    }
    async handle(inputRedirectUrl, eventEmitter) {
        if (!(await this.canHandle(inputRedirectUrl))) {
            throw new Error(`AuthCodeRedirectHandler cannot handle [${inputRedirectUrl}]: it is missing one of [code, state].`);
        }
        const url = new URL(inputRedirectUrl);
        // The type assertion is ok, because we checked in canHandle for the presence of a state
        const oauthState = url.searchParams.get("state");
        const sessionId = await getSessionIdFromOauthState(this.storageUtility, oauthState);
        if (sessionId === undefined) {
            throw new Error(`No stored session is associated with the state [${oauthState}]`);
        }
        const oidcContext = await loadOidcContextFromStorage(sessionId, this.storageUtility, this.issuerConfigFetcher);
        const issuer = new Issuer(configToIssuerMetadata(oidcContext.issuerConfig));
        // This should also retrieve the client from storage
        const clientInfo = await this.clientRegistrar.getClient({ sessionId }, oidcContext.issuerConfig);
        const client = new issuer.Client({
            client_id: clientInfo.clientId,
            client_secret: clientInfo.clientSecret,
            token_endpoint_auth_method: typeof clientInfo.clientSecret === "undefined"
                ? "none"
                : "client_secret_basic",
            id_token_signed_response_alg: clientInfo.idTokenSignedResponseAlg,
        });
        const params = client.callbackParams(inputRedirectUrl);
        let dpopKey;
        if (oidcContext.dpop) {
            dpopKey = await generateDpopKeyPair();
        }
        const tokenSet = await client.callback(removeOpenIdParams(inputRedirectUrl).href, params, { code_verifier: oidcContext.codeVerifier, state: oauthState }, 
        // The KeyLike type is dynamically bound to either KeyObject or CryptoKey
        // at runtime depending on the environment. Here, we know we are in a NodeJS
        // context.
        { DPoP: dpopKey === null || dpopKey === void 0 ? void 0 : dpopKey.privateKey });
        if (tokenSet.access_token === undefined ||
            tokenSet.id_token === undefined) {
            // The error message is left minimal on purpose not to leak the tokens.
            throw new Error(`The Identity Provider [${issuer.metadata.issuer}] did not return the expected tokens: missing at least one of 'access_token', 'id_token.`);
        }
        let refreshOptions;
        if (tokenSet.refresh_token !== undefined) {
            eventEmitter === null || eventEmitter === void 0 ? void 0 : eventEmitter.emit(EVENTS.NEW_REFRESH_TOKEN, tokenSet.refresh_token);
            refreshOptions = {
                refreshToken: tokenSet.refresh_token,
                sessionId,
                tokenRefresher: this.tokenRefresher,
            };
        }
        const authFetch = await buildAuthenticatedFetch(tokenSet.access_token, {
            dpopKey,
            refreshOptions,
            eventEmitter,
            expiresIn: tokenSet.expires_in,
        });
        // tokenSet.claims() parses the ID token, validates its signature, and returns
        // its payload as a JSON object.
        const webid = await getWebidFromTokenPayload(tokenSet.id_token, 
        // The JWKS URI is mandatory in the spec, so the non-null assertion is valid.
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        issuer.metadata.jwks_uri, issuer.metadata.issuer, client.metadata.client_id);
        await saveSessionInfoToStorage(this.storageUtility, sessionId, webid, "true", tokenSet.refresh_token, undefined, dpopKey);
        const sessionInfo = await this.sessionInfoManager.get(sessionId);
        if (!sessionInfo) {
            throw new Error(`Could not find any session information associated with SessionID [${sessionId}] in our storage.`);
        }
        return Object.assign(sessionInfo, {
            fetch: authFetch,
            expirationDate: typeof tokenSet.expires_in === "number"
                ? tokenSet.expires_in * 1000 + Date.now()
                : undefined,
            getLogoutUrl: maybeBuildRpInitiatedLogout({
                idTokenHint: tokenSet.id_token,
                endSessionEndpoint: oidcContext.issuerConfig.endSessionEndpoint,
            }),
        });
    }
}

//
// Copyright Inrupt Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
// Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
// eslint-disable-next-line no-shadow
/**
 * This class handles redirect IRIs without any query params, and returns an unauthenticated
 * session. It serves as a fallback so that consuming libraries don't have to test
 * for the query params themselves, and can always try to use them as a redirect IRI.
 * @hidden
 */
class FallbackRedirectHandler {
    async canHandle(redirectUrl) {
        try {
            // The next URL object is built for validating it.
            // eslint-disable-next-line no-new
            new URL(redirectUrl);
            return true;
        }
        catch (e) {
            throw new Error(`[${redirectUrl}] is not a valid URL, and cannot be used as a redirect URL: ${e}`);
        }
    }
    async handle(
    // The argument is ignored, but must be present to implement the interface
    _redirectUrl) {
        return getUnauthenticatedSession();
    }
}

//
// Copyright Inrupt Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
// Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
/**
 * @hidden
 */
class AggregateIncomingRedirectHandler extends AggregateHandler {
    constructor(redirectHandlers) {
        super(redirectHandlers);
    }
}

//
// Copyright Inrupt Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
// Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
/**
 * @hidden
 */
class Redirector {
    redirect(redirectUrl, options) {
        if (options && options.handleRedirect) {
            options.handleRedirect(redirectUrl);
        }
        else {
            throw new Error("A redirection handler must be provided in the Node environment.");
        }
    }
}

//
// Copyright Inrupt Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
// Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
function negotiateClientSigningAlg(issuerConfig, clientPreference) {
    if (!Array.isArray(issuerConfig.idTokenSigningAlgValuesSupported)) {
        throw new Error("The OIDC issuer discovery profile is missing the 'id_token_signing_alg_values_supported' value, which is mandatory.");
    }
    const signingAlg = determineSigningAlg(issuerConfig.idTokenSigningAlgValuesSupported, clientPreference);
    if (signingAlg === null) {
        throw new Error(`No signature algorithm match between ${JSON.stringify(issuerConfig.idTokenSigningAlgValuesSupported)} supported by the Identity Provider and ${JSON.stringify(clientPreference)} preferred by the client.`);
    }
    return signingAlg;
}
/**
 * @hidden
 */
class ClientRegistrar {
    constructor(storageUtility) {
        this.storageUtility = storageUtility;
        this.storageUtility = storageUtility;
    }
    async getClient(options, issuerConfig) {
        var _a;
        // If client secret and/or client id are stored in storage, use those.
        const [storedClientId, storedClientSecret, storedClientName, storedIdTokenSignedResponseAlg, storedClientType,] = await Promise.all([
            this.storageUtility.getForUser(options.sessionId, "clientId"),
            this.storageUtility.getForUser(options.sessionId, "clientSecret"),
            this.storageUtility.getForUser(options.sessionId, "clientName"),
            this.storageUtility.getForUser(options.sessionId, "idTokenSignedResponseAlg"),
            this.storageUtility.getForUser(options.sessionId, "clientType"),
        ]);
        if (storedClientId !== undefined && isKnownClientType(storedClientType)) {
            if (storedClientType === "static" && storedClientSecret === undefined) {
                throw new Error("Missing static client secret in storage.");
            }
            return {
                clientId: storedClientId,
                clientSecret: storedClientSecret,
                clientName: storedClientName,
                idTokenSignedResponseAlg: storedIdTokenSignedResponseAlg !== null && storedIdTokenSignedResponseAlg !== void 0 ? storedIdTokenSignedResponseAlg : negotiateClientSigningAlg(issuerConfig, PREFERRED_SIGNING_ALG),
                clientType: storedClientType,
            };
        }
        // TODO: It would be more efficient to only issue a single request (see IssuerConfigFetcher)
        const issuer = new Issuer(configToIssuerMetadata(issuerConfig));
        if (issuer.metadata.registration_endpoint === undefined) {
            throw new ConfigurationError(`Dynamic client registration cannot be performed, because issuer does not have a registration endpoint: ${JSON.stringify(issuer.metadata)}`);
        }
        const signingAlg = negotiateClientSigningAlg(issuerConfig, PREFERRED_SIGNING_ALG);
        // The following is compliant with the example code, but seems to mismatch the
        // type annotations.
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        const registeredClient = await issuer.Client.register({
            redirect_uris: [options.redirectUrl],
            client_name: options.clientName,
            // See https://openid.net/specs/openid-connect-registration-1_0.html
            id_token_signed_response_alg: signingAlg,
            grant_types: ["authorization_code", "refresh_token"],
        });
        const persistedClientMetadata = {
            clientId: registeredClient.metadata.client_id,
            idTokenSignedResponseAlg: (_a = registeredClient.metadata.id_token_signed_response_alg) !== null && _a !== void 0 ? _a : signingAlg,
            clientType: "dynamic",
        };
        if (registeredClient.metadata.client_secret !== undefined) {
            persistedClientMetadata.clientSecret =
                registeredClient.metadata.client_secret;
        }
        await this.storageUtility.setForUser(options.sessionId, persistedClientMetadata);
        return {
            clientId: persistedClientMetadata.clientId,
            clientSecret: persistedClientMetadata.clientSecret,
            idTokenSignedResponseAlg: persistedClientMetadata.idTokenSignedResponseAlg,
            clientName: registeredClient.metadata.client_name,
            clientType: "dynamic",
        };
    }
}

//
// Copyright Inrupt Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
// Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
// Some identifiers are not in camelcase on purpose, as they are named using the
// official names from the OIDC/OAuth2 specifications.
/* eslint-disable camelcase */
const tokenSetToTokenEndpointResponse = (tokenSet, issuerMetadata) => {
    if (tokenSet.access_token === undefined) {
        // The error message is left minimal on purpose not to leak the tokens.
        throw new Error(`The Identity Provider [${issuerMetadata.issuer}] did not return an access token on refresh.`);
    }
    if (tokenSet.token_type !== "Bearer" && tokenSet.token_type !== "DPoP") {
        throw new Error(`The Identity Provider [${issuerMetadata.issuer}] returned an unknown token type: [${tokenSet.token_type}].`);
    }
    return {
        accessToken: tokenSet.access_token,
        tokenType: tokenSet.token_type,
        idToken: tokenSet.id_token,
        refreshToken: tokenSet.refresh_token,
        expiresAt: tokenSet.expires_at,
    };
};
/**
 * @hidden
 */
class TokenRefresher {
    constructor(storageUtility, issuerConfigFetcher, clientRegistrar) {
        this.storageUtility = storageUtility;
        this.issuerConfigFetcher = issuerConfigFetcher;
        this.clientRegistrar = clientRegistrar;
        this.storageUtility = storageUtility;
        this.issuerConfigFetcher = issuerConfigFetcher;
        this.clientRegistrar = clientRegistrar;
    }
    async refresh(sessionId, refreshToken, dpopKey, eventEmitter) {
        const oidcContext = await loadOidcContextFromStorage(sessionId, this.storageUtility, this.issuerConfigFetcher);
        const issuer = new Issuer(configToIssuerMetadata(oidcContext.issuerConfig));
        // This should also retrieve the client from storage
        const clientInfo = await this.clientRegistrar.getClient({ sessionId }, oidcContext.issuerConfig);
        if (clientInfo.idTokenSignedResponseAlg === undefined) {
            clientInfo.idTokenSignedResponseAlg = negotiateClientSigningAlg(oidcContext.issuerConfig, PREFERRED_SIGNING_ALG);
        }
        const client = new issuer.Client({
            client_id: clientInfo.clientId,
            client_secret: clientInfo.clientSecret,
            token_endpoint_auth_method: typeof clientInfo.clientSecret === "undefined"
                ? "none"
                : "client_secret_basic",
            id_token_signed_response_alg: clientInfo.idTokenSignedResponseAlg,
        });
        if (refreshToken === undefined) {
            // TODO: in a next PR, look up storage for a refresh token
            throw new Error(`Session [${sessionId}] has no refresh token to allow it to refresh its access token.`);
        }
        if (oidcContext.dpop && dpopKey === undefined) {
            throw new Error(`For session [${sessionId}], the key bound to the DPoP access token must be provided to refresh said access token.`);
        }
        const tokenSet = tokenSetToTokenEndpointResponse(await client.refresh(refreshToken, {
            // openid-client does not support yet jose@3.x, and expects
            // type definitions that are no longer present. However, the JWK
            // type that we pass here is compatible with the API, hence the type
            // assertion.
            DPoP: dpopKey ? dpopKey.privateKey : undefined,
        }), issuer.metadata);
        if (tokenSet.refreshToken !== undefined) {
            eventEmitter === null || eventEmitter === void 0 ? void 0 : eventEmitter.emit(EVENTS.NEW_REFRESH_TOKEN, tokenSet.refreshToken);
            await this.storageUtility.setForUser(sessionId, {
                refreshToken: tokenSet.refreshToken,
            });
        }
        return tokenSet;
    }
}

//
// Copyright Inrupt Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
// Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
/**
 * @hidden
 */
class ClientCredentialsOidcHandler {
    constructor(tokenRefresher) {
        this.tokenRefresher = tokenRefresher;
        this.tokenRefresher = tokenRefresher;
    }
    async canHandle(oidcLoginOptions) {
        return (
        // If a redirect URL is present, the static client should use the
        // authorization code flow.
        typeof oidcLoginOptions.redirectUrl !== "string" &&
            typeof oidcLoginOptions.client.clientId === "string" &&
            typeof oidcLoginOptions.client.clientSecret === "string");
    }
    async handle(oidcLoginOptions) {
        const issuer = new Issuer(configToIssuerMetadata(oidcLoginOptions.issuerConfiguration));
        const client = new issuer.Client({
            client_id: oidcLoginOptions.client.clientId,
            client_secret: oidcLoginOptions.client.clientSecret,
        });
        let dpopKey;
        if (oidcLoginOptions.dpop) {
            dpopKey = await generateDpopKeyPair();
            // The alg property isn't set by exportJWK, so set it manually.
            [dpopKey.publicKey.alg] = PREFERRED_SIGNING_ALG;
        }
        const tokens = await client.grant({
            grant_type: "client_credentials",
            token_endpoint_auth_method: "client_secret_basic",
            scope: DEFAULT_SCOPES,
        }, {
            DPoP: oidcLoginOptions.dpop && dpopKey !== undefined
                ? dpopKey.privateKey
                : undefined,
        });
        let webId;
        if (tokens.access_token === undefined) {
            throw new Error(`Invalid response from Solid Identity Provider [${oidcLoginOptions.issuer}]: ${JSON.stringify(tokens)} is missing 'access_token'.`);
        }
        if (tokens.id_token === undefined) {
            // In the case where no ID token is provided, the access token is used to
            // get the authenticated user's WebID. This is only a temporary solution,
            // as eventually we want to move away from the Identity Provider issuing
            // Access Tokens, but by then panel work for the bot use case support will
            // have moved forward.
            webId = await getWebidFromTokenPayload(tokens.access_token, oidcLoginOptions.issuerConfiguration.jwksUri, oidcLoginOptions.issuer, 
            // When validating the Access Token, the audience should always be 'solid'
            "solid");
        }
        else {
            webId = await getWebidFromTokenPayload(tokens.id_token, oidcLoginOptions.issuerConfiguration.jwksUri, oidcLoginOptions.issuer, oidcLoginOptions.client.clientId);
        }
        const authFetch = await buildAuthenticatedFetch(tokens.access_token, {
            dpopKey,
            refreshOptions: tokens.refresh_token
                ? {
                    refreshToken: tokens.refresh_token,
                    sessionId: oidcLoginOptions.sessionId,
                    tokenRefresher: this.tokenRefresher,
                }
                : undefined,
            eventEmitter: oidcLoginOptions.eventEmitter,
            expiresIn: tokens.expires_in,
        });
        const sessionInfo = {
            isLoggedIn: true,
            sessionId: oidcLoginOptions.sessionId,
            webId,
            expirationDate: tokens.expires_in !== undefined
                ? Date.now() + tokens.expires_in * 1000
                : undefined,
        };
        return Object.assign(sessionInfo, {
            fetch: authFetch,
        });
    }
}

//
// Copyright Inrupt Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
// Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
const buildLoginHandler = (storageUtility, tokenRefresher, issuerConfigFetcher, clientRegistrar) => {
    return new OidcLoginHandler(storageUtility, new AggregateOidcHandler([
        new RefreshTokenOidcHandler(tokenRefresher, storageUtility),
        new ClientCredentialsOidcHandler(tokenRefresher),
        new AuthorizationCodeWithPkceOidcHandler(storageUtility, new Redirector()),
    ]), issuerConfigFetcher, clientRegistrar);
};
const buildRedirectHandler = (storageUtility, sessionInfoManager, issuerConfigFetcher, clientRegistrar, tokenRefresher) => {
    return new AggregateIncomingRedirectHandler([
        new AuthCodeRedirectHandler(storageUtility, sessionInfoManager, issuerConfigFetcher, clientRegistrar, tokenRefresher),
        // This catch-all class will always be able to handle the
        // redirect IRI, so it must be registered last.
        new FallbackRedirectHandler(),
    ]);
};
/**
 *
 * @param dependencies
 * @hidden
 */
function getClientAuthenticationWithDependencies(dependencies) {
    const inMemoryStorage = new InMemoryStorage();
    const secureStorage = dependencies.secureStorage || inMemoryStorage;
    const insecureStorage = dependencies.insecureStorage || inMemoryStorage;
    const storageUtility = new StorageUtilityNode(secureStorage, insecureStorage);
    const issuerConfigFetcher = new IssuerConfigFetcher(storageUtility);
    const clientRegistrar = new ClientRegistrar(storageUtility);
    const sessionInfoManager = new SessionInfoManager(storageUtility);
    const tokenRefresher = new TokenRefresher(storageUtility, issuerConfigFetcher, clientRegistrar);
    const loginHandler = buildLoginHandler(storageUtility, tokenRefresher, issuerConfigFetcher, clientRegistrar);
    const redirectHandler = buildRedirectHandler(storageUtility, sessionInfoManager, issuerConfigFetcher, clientRegistrar, tokenRefresher);
    return new ClientAuthentication(loginHandler, redirectHandler, new IWaterfallLogoutHandler(sessionInfoManager, new Redirector()), sessionInfoManager);
}

//
// Copyright Inrupt Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
// Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
/**
 * If no external storage is provided, this storage gets used.
 */
const defaultStorage = new InMemoryStorage();
/**
 * A {@link Session} object represents a user's session on an application. The session holds state, as it stores information enabling acces to private resources after login for instance.
 */
class Session {
    /**
     * Session object constructor. Typically called as follows:
     *
     * ```typescript
     * const session = new Session(
     *   {
     *     clientAuthentication: getClientAuthenticationWithDependencies({})
     *   },
     *   "mySession"
     * );
     * ```
     * @param sessionOptions The options enabling the correct instantiation of
     * the session. Either both storages or clientAuthentication are required. For
     * more information, see {@link ISessionOptions}.
     * @param sessionId A string uniquely identifying the session.
     *
     */
    constructor(sessionOptions = {}, sessionId = undefined) {
        this.tokenRequestInProgress = false;
        this.lastTimeoutHandle = 0;
        /**
         * Triggers the login process. Note that this method will redirect the user away from your app.
         *
         * @param options Parameter to customize the login behaviour. In particular, two options are mandatory: `options.oidcIssuer`, the user's identity provider, and `options.redirectUrl`, the URL to which the user will be redirected after logging in their identity provider.
         * @returns This method should redirect the user away from the app: it does not return anything. The login process is completed by {@linkcode handleIncomingRedirect}.
         */
        // Define these functions as properties so that they don't get accidentally re-bound.
        // Isn't Javascript fun?
        this.login = async (options) => {
            const loginInfo = await this.clientAuthentication.login(this.info.sessionId, {
                ...options,
            }, this.events);
            if (loginInfo !== undefined) {
                this.info.isLoggedIn = loginInfo.isLoggedIn;
                this.info.sessionId = loginInfo.sessionId;
                this.info.webId = loginInfo.webId;
                this.info.expirationDate = loginInfo.expirationDate;
            }
            if (loginInfo === null || loginInfo === void 0 ? void 0 : loginInfo.isLoggedIn) {
                // Send a signal on successful client credentials login.
                this.events.emit(EVENTS.LOGIN);
            }
        };
        /**
         * Fetches data using available login information. If the user is not logged in, this will behave as a regular `fetch`. The signature of this method is identical to the [canonical `fetch`](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).
         *
         * @param url The URL from which data should be fetched.
         * @param init Optional parameters customizing the request, by specifying an HTTP method, headers, a body, etc. Follows the [WHATWG Fetch Standard](https://fetch.spec.whatwg.org/).
         */
        this.fetch = async (url, init) => {
            if (!this.info.isLoggedIn) {
                return fetch(url, init);
            }
            return this.clientAuthentication.fetch(url, init);
        };
        /**
         * Logs the user out of the application.
         *
         * There are 2 types of logout supported by this library,
         * `app` logout and `idp` logout.
         *
         * App logout will log the user out within the application
         * by clearing any session data from the browser. It does
         * not log the user out of their Solid identity provider,
         * and should not redirect the user away.
         * App logout can be performed as follows:
         * ```typescript
         * await session.logout({ logoutType: 'app' });
         * ```
         *
         * IDP logout will log the user out of their Solid identity provider,
         * and will redirect the user away from the application to do so. In order
         * for users to be redirected back to `postLogoutUrl` you MUST include the
         * `postLogoutUrl` value in the `post_logout_redirect_uris` field in the
         * [Client ID Document](https://docs.inrupt.com/ess/latest/security/authentication/#client-identifier-client-id).
         * IDP logout can be performed as follows:
         * ```typescript
         * await session.logout({
         *  logoutType: 'idp',
         *  // An optional URL to redirect to after logout has completed;
         *  // this MUST match a logout URL listed in the Client ID Document
         *  // of the application that is logged in.
         *  // If the application is logged in with a Client ID that is not
         *  // a URI dereferencing to a Client ID Document then users will
         *  // not be redirected back to the `postLogoutUrl` after logout.
         *  postLogoutUrl: 'https://example.com/logout',
         *  // An optional value to be included in the query parameters
         *  // when the IDP provider redirects the user to the postLogoutRedirectUrl.
         *  state: "my-state"
         * });
         * ```
         */
        this.logout = async (options) => this.internalLogout(true, options);
        this.internalLogout = async (emitEvent, options) => {
            await this.clientAuthentication.logout(this.info.sessionId, options);
            // Clears the timeouts on logout so that Node does not hang.
            clearTimeout(this.lastTimeoutHandle);
            this.info.isLoggedIn = false;
            if (emitEvent) {
                this.events.emit(EVENTS.LOGOUT);
            }
        };
        /**
         * Completes the login process by processing the information provided by the identity provider through redirect.
         *
         * @param url The URL of the page handling the redirect, including the query parameters — these contain the information to process the login.
         */
        this.handleIncomingRedirect = async (url) => {
            let sessionInfo;
            if (this.info.isLoggedIn) {
                sessionInfo = this.info;
            }
            else if (this.tokenRequestInProgress) ;
            else {
                try {
                    this.tokenRequestInProgress = true;
                    sessionInfo = await this.clientAuthentication.handleIncomingRedirect(url, this.events);
                    if (sessionInfo) {
                        this.info.isLoggedIn = sessionInfo.isLoggedIn;
                        this.info.webId = sessionInfo.webId;
                        this.info.sessionId = sessionInfo.sessionId;
                        if (sessionInfo.isLoggedIn) {
                            // The login event can only be triggered **after** the user has been
                            // redirected from the IdP with access and ID tokens.
                            this.events.emit(EVENTS.LOGIN);
                        }
                    }
                }
                finally {
                    this.tokenRequestInProgress = false;
                }
            }
            return sessionInfo;
        };
        this.events = new EventEmitter();
        if (sessionOptions.clientAuthentication) {
            this.clientAuthentication = sessionOptions.clientAuthentication;
        }
        else if (sessionOptions.storage) {
            this.clientAuthentication = getClientAuthenticationWithDependencies({
                secureStorage: sessionOptions.storage,
                insecureStorage: sessionOptions.storage,
            });
        }
        else if (sessionOptions.secureStorage && sessionOptions.insecureStorage) {
            this.clientAuthentication = getClientAuthenticationWithDependencies({
                secureStorage: sessionOptions.secureStorage,
                insecureStorage: sessionOptions.insecureStorage,
            });
        }
        else {
            this.clientAuthentication = getClientAuthenticationWithDependencies({
                secureStorage: defaultStorage,
                insecureStorage: defaultStorage,
            });
        }
        if (sessionOptions.sessionInfo) {
            this.info = {
                sessionId: sessionOptions.sessionInfo.sessionId,
                isLoggedIn: false,
                webId: sessionOptions.sessionInfo.webId,
            };
        }
        else {
            this.info = {
                sessionId: sessionId !== null && sessionId !== void 0 ? sessionId : v4(),
                isLoggedIn: false,
            };
        }
        // Keeps track of the latest timeout handle in order to clean up on logout
        // and not leave open timeouts.
        this.events.on(EVENTS.TIMEOUT_SET, (timeoutHandle) => {
            this.lastTimeoutHandle = timeoutHandle;
        });
        this.events.on(EVENTS.ERROR, () => this.internalLogout(false));
        this.events.on(EVENTS.SESSION_EXPIRED, () => this.internalLogout(false));
    }
}

//
// Copyright Inrupt Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
// Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
/**
 * Retrieve a Session from the given storage based on its session ID. If possible,
 * the Session is logged in before it is returned, so that `session.fetch` may
 * access private Resource without any additional interaction.
 *
 * If no storage is provided, a default in-memory storage will be used. It is
 * instanciated once on load, and is shared across all the sessions. Since it
 * is only available in memory, the storage is lost when the code stops running.
 *
 * A Session is available in storage as soon as it logged in once, and it is removed
 * from storage on logout.
 *
 * @param sessionId The ID of the Session to retrieve
 * @param storage The storage where the Session can be found
 * @returns A session object, authenticated if possible, or undefined if no Session
 * in storage matches the given ID.
 */
async function getSessionFromStorage(sessionId, storage, onNewRefreshToken) {
    const clientAuth = storage
        ? getClientAuthenticationWithDependencies({
            secureStorage: storage,
            insecureStorage: storage,
        })
        : getClientAuthenticationWithDependencies({
            secureStorage: defaultStorage,
            insecureStorage: defaultStorage,
        });
    const sessionInfo = await clientAuth.getSessionInfo(sessionId);
    if (sessionInfo === undefined) {
        return undefined;
    }
    const session = new Session({
        sessionInfo,
        clientAuthentication: clientAuth,
    });
    if (onNewRefreshToken !== undefined) {
        session.events.on(EVENTS.NEW_REFRESH_TOKEN, onNewRefreshToken);
    }
    if (sessionInfo.refreshToken) {
        await session.login({
            oidcIssuer: sessionInfo.issuer,
        });
    }
    return session;
}
/**
 * Retrieve the IDs for all the Sessions available in the given storage. Note that
 * it is only the Session IDs that are returned, and not Session object. Given a
 * Session ID, one may use [[getSessionFromStorage]] to get the actual Session
 * object, while being conscious that logging in a Session required an HTTP
 * interaction, so doing it in batch for a large number of sessions may result
 * in performance issues.
 *
 * If no storage is provided, a default in-memory storage will be used. It is
 * instanciated once on load, and is shared across all the sessions. Since it
 * is only available in memory, the storage is lost when the code stops running.
 *
 * A Session is available in storage as soon as it logged in once, and it is removed
 * from storage on logout.
 *
 * @param storage The storage where the Session can be found
 * @returns An array of Session IDs
 */
async function getSessionIdFromStorageAll(storage) {
    const clientAuth = storage
        ? getClientAuthenticationWithDependencies({
            secureStorage: storage,
            insecureStorage: storage,
        })
        : getClientAuthenticationWithDependencies({
            secureStorage: defaultStorage,
            insecureStorage: defaultStorage,
        });
    return clientAuth.getSessionIdAll();
}
/**
 * Clear the given storage from any existing Session ID. In order to remove an
 * individual Session from storage, rather than going through this batch deletion,
 * one may simply log the Session out calling `session.logout`.
 *
 * If no storage is provided, a default in-memory storage will be used. It is
 * instanciated once on load, and is shared across all the sessions. Since it
 * is only available in memory, the storage is lost when the code stops running.
 *
 * A Session is available in storage as soon as it logged in once, and it is removed
 * from storage on logout.
 *
 * @param storage The storage where the Session can be found
 */
async function clearSessionFromStorageAll(storage) {
    const clientAuth = storage
        ? getClientAuthenticationWithDependencies({
            secureStorage: storage,
            insecureStorage: storage,
        })
        : getClientAuthenticationWithDependencies({
            secureStorage: defaultStorage,
            insecureStorage: defaultStorage,
        });
    return clientAuth.clearSessionAll();
}

export { Session, clearSessionFromStorageAll, getSessionFromStorage, getSessionIdFromStorageAll };
//# sourceMappingURL=index.mjs.map
