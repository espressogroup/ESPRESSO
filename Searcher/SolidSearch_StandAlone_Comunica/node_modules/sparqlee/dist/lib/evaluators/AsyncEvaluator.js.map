{"version":3,"file":"AsyncEvaluator.js","sourceRoot":"","sources":["../../../lib/evaluators/AsyncEvaluator.ts"],"names":[],"mappings":";;;AACA,sCAAsC;AAGtC,2EAAwE;AAGxE,wFAAqF;AAarF,MAAa,cAAc;IAoBzB,YAA0B,OAAuB,EAAE,UAAkC,EAAE;QAA7D,YAAO,GAAP,OAAO,CAAgB;QAC/C,wDAAwD;QACxD,MAAM,OAAO,GAAG,OAAO,CAAC,wBAAwB,IAAI,CAAC,GAAG,EAAE,CAAC,SAAS,CAAC,CAAC;QACtE,MAAM,WAAW,GAAG,cAAc,CAAC,eAAe,CAAC,OAAO,CAAC,CAAC;QAE5D,MAAM,WAAW,GAAG,IAAI,uCAAkB,iBACxC,IAAI,EAAE,OAAO,EACb,OAAO,IACJ,WAAW,EACd,CAAC;QACH,IAAI,CAAC,IAAI,GAAG,WAAW,CAAC,gBAAgB,CAAC,OAAO,CAAC,CAAC;QAElD,IAAI,CAAC,SAAS,GAAG,IAAI,iDAAuB,CAAC,WAAW,EAAE,WAAW,CAAC,CAAC;IACzE,CAAC;IA7BM,MAAM,CAAC,eAAe,CAAC,OAA+B;QAC3D,OAAO;YACL,GAAG,EAAE,OAAO,CAAC,GAAG,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC;YACxC,OAAO,EAAE,OAAO,CAAC,OAAO,IAAI,SAAS;YACrC,sBAAsB,EAAE,OAAO,CAAC,sBAAsB,IAAI,EAAE;YAC5D,iBAAiB,EAAE;gBACjB,KAAK,EAAE,OAAO,CAAC,SAAS,IAAI,IAAI,QAAQ,EAAE;gBAC1C,UAAU,EAAE,OAAO,CAAC,YAAY,IAAI,CAAC,GAAG,EAAE,CAAC,MAAM,CAAC;aACnD;YACD,wBAAwB,EAAE,OAAO,CAAC,wBAAwB;YAC1D,MAAM,EAAE,OAAO,CAAC,MAAM;YACtB,SAAS,EAAE,OAAO,CAAC,SAAS;YAC5B,KAAK,EAAE,OAAO,CAAC,KAAK;SACrB,CAAC;IACJ,CAAC;IAiBM,KAAK,CAAC,QAAQ,CAAC,OAAqB;QACzC,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QACjE,OAAO,MAAM,CAAC,KAAK,EAAE,CAAC;IACxB,CAAC;IAEM,KAAK,CAAC,aAAa,CAAC,OAAqB;QAC9C,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QACjE,OAAO,MAAM,CAAC,SAAS,EAAE,CAAC;IAC5B,CAAC;IAEM,KAAK,CAAC,kBAAkB,CAAC,OAAqB;QACnD,OAAO,MAAM,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;IAC3D,CAAC;CACF;AAhDD,wCAgDC","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport * as LRUCache from 'lru-cache';\nimport type { Algebra as Alg } from 'sparqlalgebrajs';\nimport type * as E from '../expressions/Expressions';\nimport { AlgebraTransformer } from '../transformers/AlgebraTransformer';\nimport type { IExpressionEvaluator } from '../Types';\nimport type { ICompleteAsyncEvaluatorContext } from './evaluatorHelpers/AsyncRecursiveEvaluator';\nimport { AsyncRecursiveEvaluator } from './evaluatorHelpers/AsyncRecursiveEvaluator';\nimport type { ISharedContext } from './evaluatorHelpers/BaseExpressionEvaluator';\n\nexport type AsyncExtensionFunction = (args: RDF.Term[]) => Promise<RDF.Term>;\nexport type AsyncExtensionFunctionCreator = (functionNamedNode: RDF.NamedNode) => AsyncExtensionFunction | undefined;\n\nexport interface IAsyncEvaluatorContext extends ISharedContext {\n  exists?: (expression: Alg.ExistenceExpression, mapping: RDF.Bindings) => Promise<boolean>;\n  aggregate?: (expression: Alg.AggregateExpression) => Promise<RDF.Term>;\n  bnode?: (input?: string) => Promise<RDF.BlankNode>;\n  extensionFunctionCreator?: AsyncExtensionFunctionCreator;\n}\n\nexport class AsyncEvaluator {\n  private readonly expr: E.Expression;\n  private readonly evaluator: IExpressionEvaluator<E.Expression, Promise<E.TermExpression>>;\n\n  public static completeContext(context: IAsyncEvaluatorContext): ICompleteAsyncEvaluatorContext {\n    return {\n      now: context.now || new Date(Date.now()),\n      baseIRI: context.baseIRI || undefined,\n      functionArgumentsCache: context.functionArgumentsCache || {},\n      superTypeProvider: {\n        cache: context.typeCache || new LRUCache(),\n        discoverer: context.getSuperType || (() => 'term'),\n      },\n      extensionFunctionCreator: context.extensionFunctionCreator,\n      exists: context.exists,\n      aggregate: context.aggregate,\n      bnode: context.bnode,\n    };\n  }\n\n  public constructor(public algExpr: Alg.Expression, context: IAsyncEvaluatorContext = {}) {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const creator = context.extensionFunctionCreator || (() => undefined);\n    const baseContext = AsyncEvaluator.completeContext(context);\n\n    const transformer = new AlgebraTransformer({\n      type: 'async',\n      creator,\n      ...baseContext,\n    });\n    this.expr = transformer.transformAlgebra(algExpr);\n\n    this.evaluator = new AsyncRecursiveEvaluator(baseContext, transformer);\n  }\n\n  public async evaluate(mapping: RDF.Bindings): Promise<RDF.Term> {\n    const result = await this.evaluator.evaluate(this.expr, mapping);\n    return result.toRDF();\n  }\n\n  public async evaluateAsEBV(mapping: RDF.Bindings): Promise<boolean> {\n    const result = await this.evaluator.evaluate(this.expr, mapping);\n    return result.coerceEBV();\n  }\n\n  public async evaluateAsInternal(mapping: RDF.Bindings): Promise<E.TermExpression> {\n    return await this.evaluator.evaluate(this.expr, mapping);\n  }\n}\n"]}