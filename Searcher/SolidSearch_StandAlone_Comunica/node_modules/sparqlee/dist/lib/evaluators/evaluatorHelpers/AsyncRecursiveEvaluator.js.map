{"version":3,"file":"AsyncRecursiveEvaluator.js","sourceRoot":"","sources":["../../../../lib/evaluators/evaluatorHelpers/AsyncRecursiveEvaluator.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport type { Algebra as Alg } from 'sparqlalgebrajs';\nimport * as E from '../../expressions';\nimport type { AsyncExtension } from '../../expressions';\nimport type { EvalContextAsync } from '../../functions';\nimport type { ITermTransformer } from '../../transformers/TermTransformer';\nimport { TermTransformer } from '../../transformers/TermTransformer';\nimport type { IExpressionEvaluator } from '../../Types';\nimport * as Err from '../../util/Errors';\nimport type { ISuperTypeProvider } from '../../util/TypeHandling';\nimport type { AsyncExtensionFunctionCreator } from '../AsyncEvaluator';\nimport { BaseExpressionEvaluator } from './BaseExpressionEvaluator';\nimport type { ICompleteSharedContext } from './BaseExpressionEvaluator';\n\nexport interface ICompleteAsyncEvaluatorContext extends ICompleteSharedContext {\n  exists?: (expression: Alg.ExistenceExpression, mapping: RDF.Bindings) => Promise<boolean>;\n  aggregate?: (expression: Alg.AggregateExpression) => Promise<RDF.Term>;\n  bnode?: (input?: string) => Promise<RDF.BlankNode>;\n  extensionFunctionCreator?: AsyncExtensionFunctionCreator;\n}\n\nexport class AsyncRecursiveEvaluator extends BaseExpressionEvaluator\n  implements IExpressionEvaluator<E.Expression, Promise<E.Term>> {\n  protected openWorldType: ISuperTypeProvider;\n  private readonly subEvaluators: Record<string, (expr: E.Expression, mapping: RDF.Bindings) =>\n  Promise<E.Term> | E.Term> = {\n    // Shared\n    [E.ExpressionType.Term]: this.term.bind(this),\n    [E.ExpressionType.Variable]: this.variable.bind(this),\n\n    // Async\n    [E.ExpressionType.Operator]: this.evalOperator.bind(this),\n    [E.ExpressionType.SpecialOperator]: this.evalSpecialOperator.bind(this),\n    [E.ExpressionType.Named]: this.evalNamed.bind(this),\n    [E.ExpressionType.Existence]: this.evalExistence.bind(this),\n    [E.ExpressionType.Aggregate]: this.evalAggregate.bind(this),\n    [E.ExpressionType.AsyncExtension]: this.evalAsyncExtension.bind(this),\n  };\n\n  public constructor(private readonly context: ICompleteAsyncEvaluatorContext, termTransformer?: ITermTransformer) {\n    super(termTransformer || new TermTransformer(context.superTypeProvider));\n  }\n\n  public async evaluate(expr: E.Expression, mapping: RDF.Bindings): Promise<E.Term> {\n    const evaluator = this.subEvaluators[expr.expressionType];\n    if (!evaluator) {\n      throw new Err.InvalidExpressionType(expr);\n    }\n    return evaluator.bind(this)(expr, mapping);\n  }\n\n  private async evalOperator(expr: E.Operator, mapping: RDF.Bindings): Promise<E.Term> {\n    const argPromises = expr.args.map(arg => this.evaluate(arg, mapping));\n    const argResults = await Promise.all(argPromises);\n    return expr.apply(argResults);\n  }\n\n  private async evalSpecialOperator(expr: E.SpecialOperator, mapping: RDF.Bindings): Promise<E.Term> {\n    const evaluate = this.evaluate.bind(this);\n    const context: EvalContextAsync = {\n      args: expr.args,\n      mapping,\n\n      superTypeProvider: this.context.superTypeProvider,\n      now: this.context.now,\n      baseIRI: this.context.baseIRI,\n      functionArgumentsCache: this.context.functionArgumentsCache,\n\n      evaluate,\n      bnode: this.context.bnode,\n    };\n    return expr.applyAsync(context);\n  }\n\n  private async _evalAsyncArgs(args: E.Expression[], mapping: RDF.Bindings): Promise<E.TermExpression[]> {\n    const argPromises = args.map(arg => this.evaluate(arg, mapping));\n    return await Promise.all(argPromises);\n  }\n\n  private async evalNamed(expr: E.Named, mapping: RDF.Bindings): Promise<E.Term> {\n    return expr.apply(await this._evalAsyncArgs(expr.args, mapping));\n  }\n\n  private async evalAsyncExtension(expr: AsyncExtension, mapping: RDF.Bindings): Promise<E.Term> {\n    return await expr.apply(await this._evalAsyncArgs(expr.args, mapping));\n  }\n\n  private async evalExistence(expr: E.Existence, mapping: RDF.Bindings): Promise<E.Term> {\n    if (!this.context.exists) {\n      throw new Err.NoExistenceHook();\n    }\n\n    return new E.BooleanLiteral(await this.context.exists(expr.expression, mapping));\n  }\n\n  // TODO: Remove?\n  private async evalAggregate(expr: E.Aggregate, _mapping: RDF.Bindings): Promise<E.Term> {\n    if (!this.context.aggregate) {\n      throw new Err.NoAggregator();\n    }\n\n    return this.termTransformer.transformRDFTermUnsafe(await this.context.aggregate(expr.expression));\n  }\n}\n"]}