{"version":3,"file":"Parsing.js","sourceRoot":"","sources":["../../../lib/util/Parsing.ts"],"names":[],"mappings":";AAAA,gCAAgC;;;AAEhC;;;;;;;GAOG;AACH,SAAgB,aAAa,CAAC,KAAa;IACzC,MAAM,IAAI,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC;IAC3B,IAAI,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE;QACtB,IAAI,KAAK,KAAK,KAAK,EAAE;YACnB,OAAO,MAAM,CAAC,GAAG,CAAC;SACnB;QACD,IAAI,KAAK,KAAK,KAAK,IAAI,KAAK,KAAK,MAAM,EAAE;YACvC,OAAO,MAAM,CAAC,iBAAiB,CAAC;SACjC;QACD,IAAI,KAAK,KAAK,MAAM,EAAE;YACpB,OAAO,MAAM,CAAC,iBAAiB,CAAC;SACjC;QACD,OAAO,SAAS,CAAC;KAClB;IACD,OAAO,IAAI,CAAC;AACd,CAAC;AAfD,sCAeC;AAED;;;;;;;GAOG;AACH,SAAgB,eAAe,CAAC,KAAa;IAC3C,MAAM,IAAI,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC;IAC3B,OAAO,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC;AAC/C,CAAC;AAHD,0CAGC;AAED;;;;;;;GAOG;AACH,SAAgB,eAAe,CAAC,KAAa;IAC3C,MAAM,IAAI,GAAW,MAAM,CAAC,QAAQ,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;IAChD,OAAO,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC;AAC/C,CAAC;AAHD,0CAGC;AAYD;;;;;;;;;;;;GAYG;AACH,SAAgB,gBAAgB,CAAC,KAAa;IAC5C,MAAM,IAAI,GAAG,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;IAChC,MAAM,IAAI,GAAG,IAAI,IAAI,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;IACnE,MAAM,CAAE,IAAI,EAAE,KAAK,EAAE,GAAG,CAAE,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;IAC7C,IAAI,KAAK,GAAG,IAAI,CAAC;IACjB,IAAI,OAAO,GAAG,IAAI,CAAC;IACnB,IAAI,OAAO,GAAG,IAAI,CAAC;IACnB,IAAI,QAAQ,GAAG,EAAE,CAAC;IAClB,IAAI,IAAI,IAAI,CAAC,EAAE;QACb,MAAM,eAAe,GAAG,KAAK,CAAC,KAAK,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC;QAC9C,MAAM,CAAE,IAAI,EAAE,gBAAgB,CAAE,GAAG,eAAe,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;QACnE,CAAE,KAAK,EAAE,OAAO,EAAE,OAAO,CAAE,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QAC9C,MAAM,cAAc,GAAG,YAAY,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;QAC1D,QAAQ,GAAG,cAAc,CAAC,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;KACpD;IACD,OAAO,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,EAAE,KAAK,EAAE,OAAO,EAAE,OAAO,EAAE,QAAQ,EAAE,CAAC;AACjE,CAAC;AAhBD,4CAgBC","sourcesContent":["// TODO: Find a library for this\n\n/**\n * TODO: Fix decently\n * Parses float datatypes (double, float).\n *\n * All invalid lexical values return undefined.\n *\n * @param value the string to interpret as a number\n */\nexport function parseXSDFloat(value: string): number | undefined {\n  const numb = Number(value);\n  if (Number.isNaN(numb)) {\n    if (value === 'NaN') {\n      return Number.NaN;\n    }\n    if (value === 'INF' || value === '+INF') {\n      return Number.POSITIVE_INFINITY;\n    }\n    if (value === '-INF') {\n      return Number.NEGATIVE_INFINITY;\n    }\n    return undefined;\n  }\n  return numb;\n}\n\n/**\n * Parses decimal datatypes (decimal, int, byte, nonPositiveInteger, etc...).\n *\n * All other values, including NaN, INF, and floating point numbers all\n * return undefined;\n *\n * @param value the string to interpret as a number\n */\nexport function parseXSDDecimal(value: string): number | undefined {\n  const numb = Number(value);\n  return Number.isNaN(numb) ? undefined : numb;\n}\n\n/**\n * Parses integer datatypes (decimal, int, byte, nonPositiveInteger, etc...).\n *\n * All other values, including NaN, INF, and floating point numbers all\n * return undefined;\n *\n * @param value the string to interpret as a number\n */\nexport function parseXSDInteger(value: string): number | undefined {\n  const numb: number = Number.parseInt(value, 10);\n  return Number.isNaN(numb) ? undefined : numb;\n}\n\nexport interface ISplittedDate {\n  year: string;\n  month: string;\n  day: string;\n  hours: string;\n  minutes: string;\n  seconds: string;\n  timezone: string;\n}\n\n/**\n * Parses ISO date or date time strings into it's parts.\n * I found no lib providing this functionality online, but it's needed heavily\n * by the spec (functions on dates), using any form of JS DateTime will lose the\n * original timezone notation.\n *\n * Example strings:\n *  - \"2011-01-10T14:45:13.815-05:00\"\n *  - \"2011-01-10T14:45:13.815Z\"\n *  - \"2011-01-10T14:45:13Z\"\n *  - \"2011-01-10\"\n * @param value the ISO date time string\n */\nexport function parseXSDDateTime(value: string): ISplittedDate {\n  const posT = value.indexOf('T');\n  const date = posT >= 0 ? value.slice(0, Math.max(0, posT)) : value;\n  const [ year, month, day ] = date.split('-');\n  let hours = '00';\n  let minutes = '00';\n  let seconds = '00';\n  let timezone = '';\n  if (posT >= 0) {\n    const timeAndTimeZone = value.slice(posT + 1);\n    const [ time, _timeZoneChopped ] = timeAndTimeZone.split(/[+Z-]/u);\n    [ hours, minutes, seconds ] = time.split(':');\n    const timezoneOrNull = /([+Z-].*)/u.exec(timeAndTimeZone);\n    timezone = timezoneOrNull ? timezoneOrNull[0] : '';\n  }\n  return { year, month, day, hours, minutes, seconds, timezone };\n}\n"]}