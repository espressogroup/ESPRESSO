"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthCodeRedirectHandler = void 0;
const solid_client_authn_core_1 = require("@inrupt/solid-client-authn-core");
const url_1 = require("url");
const openid_client_1 = require("openid-client");
const universal_fetch_1 = require("@inrupt/universal-fetch");
const IssuerConfigFetcher_1 = require("../IssuerConfigFetcher");
class AuthCodeRedirectHandler {
    constructor(storageUtility, sessionInfoManager, issuerConfigFetcher, clientRegistrar, tokenRefresher) {
        this.storageUtility = storageUtility;
        this.sessionInfoManager = sessionInfoManager;
        this.issuerConfigFetcher = issuerConfigFetcher;
        this.clientRegistrar = clientRegistrar;
        this.tokenRefresher = tokenRefresher;
    }
    async canHandle(redirectUrl) {
        try {
            const myUrl = new url_1.URL(redirectUrl);
            return (myUrl.searchParams.get("code") !== null &&
                myUrl.searchParams.get("state") !== null);
        }
        catch (e) {
            throw new Error(`[${redirectUrl}] is not a valid URL, and cannot be used as a redirect URL: ${e}`);
        }
    }
    async handle(inputRedirectUrl, eventEmitter) {
        if (!(await this.canHandle(inputRedirectUrl))) {
            throw new Error(`AuthCodeRedirectHandler cannot handle [${inputRedirectUrl}]: it is missing one of [code, state].`);
        }
        const url = new url_1.URL(inputRedirectUrl);
        const oauthState = url.searchParams.get("state");
        url.searchParams.delete("code");
        url.searchParams.delete("state");
        const sessionId = await (0, solid_client_authn_core_1.getSessionIdFromOauthState)(this.storageUtility, oauthState);
        if (sessionId === undefined) {
            throw new Error(`No stored session is associated with the state [${oauthState}]`);
        }
        const oidcContext = await (0, solid_client_authn_core_1.loadOidcContextFromStorage)(sessionId, this.storageUtility, this.issuerConfigFetcher);
        const issuer = new openid_client_1.Issuer((0, IssuerConfigFetcher_1.configToIssuerMetadata)(oidcContext.issuerConfig));
        const clientInfo = await this.clientRegistrar.getClient({ sessionId }, oidcContext.issuerConfig);
        const client = new issuer.Client({
            client_id: clientInfo.clientId,
            client_secret: clientInfo.clientSecret,
            token_endpoint_auth_method: clientInfo.clientSecret
                ? "client_secret_basic"
                : "none",
            id_token_signed_response_alg: clientInfo.idTokenSignedResponseAlg,
        });
        const params = client.callbackParams(inputRedirectUrl);
        let dpopKey;
        if (oidcContext.dpop) {
            dpopKey = await (0, solid_client_authn_core_1.generateDpopKeyPair)();
        }
        const tokenSet = await client.callback(url.href, params, { code_verifier: oidcContext.codeVerifier, state: oauthState }, { DPoP: dpopKey === null || dpopKey === void 0 ? void 0 : dpopKey.privateKey });
        const iss = url.searchParams.get("iss");
        if (typeof iss === "string" && iss !== oidcContext.issuerConfig.issuer) {
            throw new Error(`The value of the iss parameter (${iss}) does not match the issuer identifier of the authorization server (${oidcContext.issuerConfig.issuer}). See [rfc9207](https://www.rfc-editor.org/rfc/rfc9207.html#section-2.3-3.1.1)`);
        }
        if (tokenSet.access_token === undefined ||
            tokenSet.id_token === undefined) {
            throw new Error(`The Identity Provider [${issuer.metadata.issuer}] did not return the expected tokens: missing at least one of 'access_token', 'id_token.`);
        }
        let refreshOptions;
        if (tokenSet.refresh_token !== undefined) {
            eventEmitter === null || eventEmitter === void 0 ? void 0 : eventEmitter.emit(solid_client_authn_core_1.EVENTS.NEW_REFRESH_TOKEN, tokenSet.refresh_token);
            refreshOptions = {
                refreshToken: tokenSet.refresh_token,
                sessionId,
                tokenRefresher: this.tokenRefresher,
            };
        }
        const authFetch = await (0, solid_client_authn_core_1.buildAuthenticatedFetch)(universal_fetch_1.fetch, tokenSet.access_token, {
            dpopKey,
            refreshOptions,
            eventEmitter,
            expiresIn: tokenSet.expires_in,
        });
        const webid = await (0, solid_client_authn_core_1.getWebidFromTokenPayload)(tokenSet.id_token, issuer.metadata.jwks_uri, issuer.metadata.issuer, client.metadata.client_id);
        await (0, solid_client_authn_core_1.saveSessionInfoToStorage)(this.storageUtility, sessionId, webid, "true", tokenSet.refresh_token, undefined, dpopKey);
        const sessionInfo = await this.sessionInfoManager.get(sessionId);
        if (!sessionInfo) {
            throw new Error(`Could not find any session information associated with SessionID [${sessionId}] in our storage.`);
        }
        return Object.assign(sessionInfo, {
            fetch: authFetch,
            expirationDate: typeof tokenSet.expires_in === "number"
                ? tokenSet.expires_in * 1000 + Date.now()
                : undefined,
        });
    }
}
exports.AuthCodeRedirectHandler = AuthCodeRedirectHandler;
//# sourceMappingURL=AuthCodeRedirectHandler.js.map