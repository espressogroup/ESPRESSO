"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const solid_client_authn_core_1 = require("@inrupt/solid-client-authn-core");
const openid_client_1 = require("openid-client");
const universal_fetch_1 = require("@inrupt/universal-fetch");
const IssuerConfigFetcher_1 = require("../IssuerConfigFetcher");
class ClientCredentialsOidcHandler {
    constructor(tokenRefresher, _storageUtility) {
        this.tokenRefresher = tokenRefresher;
        this._storageUtility = _storageUtility;
    }
    async canHandle(oidcLoginOptions) {
        return (typeof oidcLoginOptions.client.clientId === "string" &&
            typeof oidcLoginOptions.client.clientSecret === "string" &&
            oidcLoginOptions.client.clientType === "static");
    }
    async handle(oidcLoginOptions) {
        const issuer = new openid_client_1.Issuer((0, IssuerConfigFetcher_1.configToIssuerMetadata)(oidcLoginOptions.issuerConfiguration));
        const client = new issuer.Client({
            client_id: oidcLoginOptions.client.clientId,
            client_secret: oidcLoginOptions.client.clientSecret,
        });
        let dpopKey;
        if (oidcLoginOptions.dpop) {
            dpopKey = await (0, solid_client_authn_core_1.generateDpopKeyPair)();
            [dpopKey.publicKey.alg] = solid_client_authn_core_1.PREFERRED_SIGNING_ALG;
        }
        const tokens = await client.grant({
            grant_type: "client_credentials",
            token_endpoint_auth_method: "client_secret_basic",
            scope: solid_client_authn_core_1.DEFAULT_SCOPES,
        }, {
            DPoP: oidcLoginOptions.dpop && dpopKey !== undefined
                ? dpopKey.privateKey
                : undefined,
        });
        let webId;
        if (tokens.access_token === undefined) {
            throw new Error(`Invalid response from Solid Identity Provider [${oidcLoginOptions.issuer}]: ${JSON.stringify(tokens)} is missing 'access_token'.`);
        }
        if (tokens.id_token === undefined) {
            webId = await (0, solid_client_authn_core_1.getWebidFromTokenPayload)(tokens.access_token, oidcLoginOptions.issuerConfiguration.jwksUri, oidcLoginOptions.issuer, "solid");
        }
        else {
            webId = await (0, solid_client_authn_core_1.getWebidFromTokenPayload)(tokens.id_token, oidcLoginOptions.issuerConfiguration.jwksUri, oidcLoginOptions.issuer, oidcLoginOptions.client.clientId);
        }
        const authFetch = await (0, solid_client_authn_core_1.buildAuthenticatedFetch)(universal_fetch_1.fetch, tokens.access_token, {
            dpopKey,
            refreshOptions: tokens.refresh_token
                ? {
                    refreshToken: tokens.refresh_token,
                    sessionId: oidcLoginOptions.sessionId,
                    tokenRefresher: this.tokenRefresher,
                }
                : undefined,
            eventEmitter: oidcLoginOptions.eventEmitter,
            expiresIn: tokens.expires_in,
        });
        const sessionInfo = {
            isLoggedIn: true,
            sessionId: oidcLoginOptions.sessionId,
            webId,
            expirationDate: tokens.expires_in !== undefined
                ? Date.now() + tokens.expires_in * 1000
                : undefined,
        };
        return Object.assign(sessionInfo, {
            fetch: authFetch,
        });
    }
}
exports.default = ClientCredentialsOidcHandler;
//# sourceMappingURL=ClientCredentialsOidcHandler.js.map