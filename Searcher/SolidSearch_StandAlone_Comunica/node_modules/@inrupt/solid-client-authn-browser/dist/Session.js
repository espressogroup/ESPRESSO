"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Session = exports.silentlyAuthenticate = void 0;
const solid_client_authn_core_1 = require("@inrupt/solid-client-authn-core");
const uuid_1 = require("uuid");
const events_1 = __importDefault(require("events"));
const dependencies_1 = require("./dependencies");
const constant_1 = require("./constant");
async function silentlyAuthenticate(sessionId, clientAuthn, session) {
    var _a;
    const storedSessionInfo = await clientAuthn.validateCurrentSession(sessionId);
    if (storedSessionInfo !== null) {
        window.localStorage.setItem(constant_1.KEY_CURRENT_URL, window.location.href);
        await clientAuthn.login({
            sessionId,
            prompt: "none",
            oidcIssuer: storedSessionInfo.issuer,
            redirectUrl: storedSessionInfo.redirectUrl,
            clientId: storedSessionInfo.clientAppId,
            clientSecret: storedSessionInfo.clientAppSecret,
            tokenType: (_a = storedSessionInfo.tokenType) !== null && _a !== void 0 ? _a : "DPoP",
        }, session.events);
        return true;
    }
    return false;
}
exports.silentlyAuthenticate = silentlyAuthenticate;
function isLoggedIn(sessionInfo) {
    return !!(sessionInfo === null || sessionInfo === void 0 ? void 0 : sessionInfo.isLoggedIn);
}
class Session extends events_1.default {
    constructor(sessionOptions = {}, sessionId = undefined) {
        super();
        this.tokenRequestInProgress = false;
        this.login = async (options) => {
            var _a;
            await this.clientAuthentication.login({
                sessionId: this.info.sessionId,
                ...options,
                tokenType: (_a = options.tokenType) !== null && _a !== void 0 ? _a : "DPoP",
            }, this.events);
            return new Promise(() => { });
        };
        this.fetch = async (url, init) => {
            return this.clientAuthentication.fetch(url, init);
        };
        this.internalLogout = async (emitSignal) => {
            window.localStorage.removeItem(constant_1.KEY_CURRENT_SESSION);
            await this.clientAuthentication.logout(this.info.sessionId);
            this.info.isLoggedIn = false;
            if (emitSignal) {
                this.events.emit(solid_client_authn_core_1.EVENTS.LOGOUT);
            }
        };
        this.logout = async () => this.internalLogout(true);
        this.handleIncomingRedirect = async (inputOptions = {}) => {
            var _a;
            if (this.info.isLoggedIn) {
                return this.info;
            }
            if (this.tokenRequestInProgress) {
                return undefined;
            }
            const options = typeof inputOptions === "string" ? { url: inputOptions } : inputOptions;
            const url = (_a = options.url) !== null && _a !== void 0 ? _a : window.location.href;
            this.tokenRequestInProgress = true;
            const sessionInfo = await this.clientAuthentication.handleIncomingRedirect(url, this.events);
            if (isLoggedIn(sessionInfo)) {
                this.setSessionInfo(sessionInfo);
                const currentUrl = window.localStorage.getItem(constant_1.KEY_CURRENT_URL);
                if (currentUrl === null) {
                    this.events.emit(solid_client_authn_core_1.EVENTS.LOGIN);
                }
                else {
                    window.localStorage.removeItem(constant_1.KEY_CURRENT_URL);
                    this.events.emit(solid_client_authn_core_1.EVENTS.SESSION_RESTORED, currentUrl);
                }
            }
            else if (options.restorePreviousSession === true) {
                const storedSessionId = window.localStorage.getItem(constant_1.KEY_CURRENT_SESSION);
                if (storedSessionId !== null) {
                    const attemptedSilentAuthentication = await silentlyAuthenticate(storedSessionId, this.clientAuthentication, this);
                    if (attemptedSilentAuthentication) {
                        return new Promise(() => { });
                    }
                }
            }
            this.tokenRequestInProgress = false;
            return sessionInfo;
        };
        this.events = new Proxy(this, (0, solid_client_authn_core_1.buildProxyHandler)(Session.prototype, "events only implements ISessionEventListener"));
        if (sessionOptions.clientAuthentication) {
            this.clientAuthentication = sessionOptions.clientAuthentication;
        }
        else if (sessionOptions.secureStorage && sessionOptions.insecureStorage) {
            this.clientAuthentication = (0, dependencies_1.getClientAuthenticationWithDependencies)({
                secureStorage: sessionOptions.secureStorage,
                insecureStorage: sessionOptions.insecureStorage,
            });
        }
        else {
            this.clientAuthentication = (0, dependencies_1.getClientAuthenticationWithDependencies)({});
        }
        if (sessionOptions.sessionInfo) {
            this.info = {
                sessionId: sessionOptions.sessionInfo.sessionId,
                isLoggedIn: false,
                webId: sessionOptions.sessionInfo.webId,
            };
        }
        else {
            this.info = {
                sessionId: sessionId !== null && sessionId !== void 0 ? sessionId : (0, uuid_1.v4)(),
                isLoggedIn: false,
            };
        }
        this.events.on(solid_client_authn_core_1.EVENTS.LOGIN, () => window.localStorage.setItem(constant_1.KEY_CURRENT_SESSION, this.info.sessionId));
        this.events.on(solid_client_authn_core_1.EVENTS.SESSION_EXPIRED, () => this.internalLogout(false));
        this.events.on(solid_client_authn_core_1.EVENTS.ERROR, () => this.internalLogout(false));
    }
    onLogin(callback) {
        this.events.on(solid_client_authn_core_1.EVENTS.LOGIN, callback);
    }
    onLogout(callback) {
        this.events.on(solid_client_authn_core_1.EVENTS.LOGOUT, callback);
    }
    onError(callback) {
        this.events.on(solid_client_authn_core_1.EVENTS.ERROR, callback);
    }
    onSessionRestore(callback) {
        this.events.on(solid_client_authn_core_1.EVENTS.SESSION_RESTORED, callback);
    }
    onSessionExpiration(callback) {
        this.events.on(solid_client_authn_core_1.EVENTS.SESSION_EXPIRED, callback);
    }
    setSessionInfo(sessionInfo) {
        this.info.isLoggedIn = sessionInfo.isLoggedIn;
        this.info.webId = sessionInfo.webId;
        this.info.sessionId = sessionInfo.sessionId;
        this.info.expirationDate = sessionInfo.expirationDate;
        this.events.on(solid_client_authn_core_1.EVENTS.SESSION_EXTENDED, (expiresIn) => {
            this.info.expirationDate = Date.now() + expiresIn * 1000;
        });
    }
}
exports.Session = Session;
//# sourceMappingURL=Session.js.map