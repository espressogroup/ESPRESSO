{"version":3,"file":"ActorDereferenceHttpBase.js","sourceRoot":"","sources":["ActorDereferenceHttpBase.ts"],"names":[],"mappings":"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","sourcesContent":["import type { IActionDereference, IActorDereferenceArgs, IActorDereferenceOutput } from '@comunica/bus-dereference';\nimport { ActorDereference, emptyReadable } from '@comunica/bus-dereference';\nimport type { IActorHttpOutput, MediatorHttp } from '@comunica/bus-http';\nimport { ActorHttp } from '@comunica/bus-http';\nimport type { IActorTest } from '@comunica/core';\nimport { Headers } from 'cross-fetch';\nimport { resolve as resolveRelative } from 'relative-to-absolute-iri';\nimport * as stringifyStream from 'stream-to-string';\n\nconst REGEX_MEDIATYPE = /^[^ ;]*/u;\n\nexport function mediaTypesToAcceptString(mediaTypes: Record<string, number>, maxLength: number): string {\n  const wildcard = '*/*;q=0.1';\n  const parts: string[] = [];\n  const sortedMediaTypes = Object.entries(mediaTypes)\n    .map(([ mediaType, priority ]) => ({ mediaType, priority }))\n    .sort((left, right) => right.priority === left.priority ?\n      left.mediaType.localeCompare(right.mediaType) :\n      right.priority - left.priority);\n  // Take into account the ',' characters joining each type\n  let partsLength = sortedMediaTypes.length - 1;\n  for (const { mediaType, priority } of sortedMediaTypes) {\n    const part = mediaType + (priority !== 1 ? `;q=${priority.toFixed(3).replace(/0*$/u, '')}` : '');\n    if (partsLength + part.length > maxLength) {\n      while (partsLength + wildcard.length > maxLength) {\n        const last = parts.pop() || '';\n        // Don't forget the ','\n        partsLength -= last.length + 1;\n      }\n      parts.push(wildcard);\n      break;\n    }\n    parts.push(part);\n    partsLength += part.length;\n  }\n  return parts.length === 0 ? '*/*' : parts.join(',');\n}\n\n/**\n * An actor that listens on the 'dereference' bus.\n *\n * It resolves the URL using the HTTP bus using an accept header compiled from the available media types.\n */\nexport abstract class ActorDereferenceHttpBase extends ActorDereference implements IActorDereferenceHttpArgs {\n  public readonly mediatorHttp: MediatorHttp;\n  public readonly maxAcceptHeaderLength: number;\n  public readonly maxAcceptHeaderLengthBrowser: number;\n\n  public constructor(args: IActorDereferenceHttpArgs) {\n    super(args);\n  }\n\n  public async test({ url }: IActionDereference): Promise<IActorTest> {\n    if (!/^https?:/u.test(url)) {\n      throw new Error(`Cannot retrieve ${url} because it is not an HTTP(S) URL.`);\n    }\n    return true;\n  }\n\n  public async run(action: IActionDereference): Promise<IActorDereferenceOutput> {\n    let exists = true;\n\n    // Append any custom passed headers\n    const headers = new Headers(action.headers);\n\n    // Resolve HTTP URL using appropriate accept header\n    headers.append(\n      'Accept',\n      mediaTypesToAcceptString(await action.mediaTypes?.() ?? {}, this.getMaxAcceptHeaderLength()),\n    );\n\n    let httpResponse: IActorHttpOutput;\n    const requestTimeStart = Date.now();\n    try {\n      httpResponse = await this.mediatorHttp.mediate({\n        context: action.context,\n        init: { headers, method: action.method },\n        input: action.url,\n      });\n    } catch (error: unknown) {\n      return this.handleDereferenceErrors(action, error);\n    }\n    // The response URL can be relative to the given URL\n    const url = resolveRelative(httpResponse.url, action.url);\n    const requestTime = Date.now() - requestTimeStart;\n\n    // Only parse if retrieval was successful\n    if (httpResponse.status !== 200) {\n      exists = false;\n      // Consume the body, to avoid process to hang\n      const bodyString = httpResponse.body ?\n        await stringifyStream(ActorHttp.toNodeReadable(httpResponse.body)) :\n        'empty response';\n\n      if (!action.acceptErrors) {\n        const error = new Error(`Could not retrieve ${action.url} (HTTP status ${httpResponse.status}):\\n${bodyString}`);\n        return this.handleDereferenceErrors(action, error, httpResponse.headers, requestTime);\n      }\n    }\n\n    const mediaType = REGEX_MEDIATYPE.exec(httpResponse.headers.get('content-type') ?? '')?.[0];\n\n    // Return the parsed quad stream and whether or not only triples are supported\n    return {\n      url,\n      data: exists ? ActorHttp.toNodeReadable(httpResponse.body) : emptyReadable(),\n      exists,\n      requestTime,\n      headers: httpResponse.headers,\n      mediaType: mediaType !== 'text/plain' ? mediaType : undefined,\n    };\n  }\n\n  protected abstract getMaxAcceptHeaderLength(): number;\n}\n\nexport interface IActorDereferenceHttpArgs extends IActorDereferenceArgs {\n  /**\n   * The HTTP mediator.\n   */\n  mediatorHttp: MediatorHttp;\n  /**\n   * The maximum allowed accept header value length for non-browser environments.\n   * @range {integer}\n   * @default {1024}\n   */\n  maxAcceptHeaderLength: number;\n  /**\n   * The maximum allowed accept header value length for browser environments.\n   * @range {integer}\n   * @default {128}\n   */\n  maxAcceptHeaderLengthBrowser: number;\n}\n"]}