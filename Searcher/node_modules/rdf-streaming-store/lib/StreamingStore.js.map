{"version":3,"file":"StreamingStore.js","sourceRoot":"","sources":["StreamingStore.ts"],"names":[],"mappings":";;;AAEA,2BAA2B;AAE3B,qDAA8C;AAC9C,+DAA4D;AAE5D;;;;;;;;GAQG;AACH,MAAa,cAAc;IAMzB,YAAmB,QAAsB,IAAI,UAAK,EAAK;QAHpC,mBAAc,GAA2B,IAAI,yCAAmB,EAAE,CAAC;QAC5E,UAAK,GAAG,KAAK,CAAC;QAGtB,IAAI,CAAC,KAAK,GAAO,KAAK,CAAC;IACzB,CAAC;IAED;;;;;OAKG;IACI,GAAG;QACR,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;QAElB,oCAAoC;QACpC,KAAK,MAAM,aAAa,IAAI,IAAI,CAAC,cAAc,CAAC,UAAU,EAAE;YAC1D,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YAClB,aAAc,CAAC,WAAW,CAAC,MAAM,EAAE,CAAC;SAC5C;IACH,CAAC;IAES,iBAAiB,CAAC,MAAqB;QAC/C,MAAM,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,IAAO,EAAE,EAAE;YAC5B,KAAK,MAAM,aAAa,IAAI,IAAI,CAAC,cAAc,CAAC,wBAAwB,CAAC,IAAI,CAAC,EAAE;gBAC9E,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE;oBACf,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;iBAC1B;aACF;QACH,CAAC,CAAC,CAAC;IACL,CAAC;IAEM,MAAM,CAAC,MAAqB;QACjC,IAAI,IAAI,CAAC,KAAK,EAAE;YACd,MAAM,IAAI,KAAK,CAAC,kDAAkD,CAAC,CAAC;SACrE;QAED,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAC,CAAC;QAC/B,OAAO,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;IACnC,CAAC;IAEM,KAAK,CACV,OAAyB,EACzB,SAA2B,EAC3B,MAAwB,EACxB,KAAuB;QAEvB,MAAM,WAAW,GAAwB,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,OAAO,EAAE,SAAS,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC;QAC7F,IAAI,MAAM,GAAkB,WAAW,CAAC;QAExC,iEAAiE;QACjE,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE;YACf,gEAAgE;YAChE,MAAM,aAAa,GAAG,IAAI,6BAAW,CAAC,EAAE,UAAU,EAAE,IAAI,EAAE,CAAC,CAAC;YAC5D,IAAI,CAAC,cAAc,CAAC,kBAAkB,CAAC,aAAa,EAAE,OAAO,EAAE,SAAS,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC;YACzF,MAAM,GAAG,WAAW,CAAC,IAAI,CAAC,aAAa,EAAE,EAAE,GAAG,EAAE,KAAK,EAAE,CAAC,CAAC;YAClD,MAAO,CAAC,WAAW,GAAG,WAAW,CAAC;SAC1C;QACD,OAAO,MAAM,CAAC;IAChB,CAAC;IAED;;OAEG;IACI,QAAQ;QACb,OAAO,IAAI,CAAC,KAAK,CAAC;IACpB,CAAC;CACF;AAvED,wCAuEC","sourcesContent":["import type { EventEmitter } from 'events';\nimport type * as RDF from '@rdfjs/types';\nimport { Store } from 'n3';\nimport type { Readable } from 'readable-stream';\nimport { PassThrough } from 'readable-stream';\nimport { PendingStreamsIndex } from './PendingStreamsIndex';\n\n/**\n * A StreamingStore allows data lookup and insertion to happen in parallel.\n * Concretely, this means that `match()` calls happening before `import()` calls, will still consider those triples that\n * are inserted later, which is done by keeping the response streams of `match()` open.\n * Only when the `end()` method is invoked, all response streams will close, and the StreamingStore will be considered\n * immutable.\n *\n * WARNING: `end()` MUST be called at some point, otherwise all `match` streams will remain unended.\n */\nexport class StreamingStore<Q extends RDF.BaseQuad = RDF.Quad, S extends RDF.Store<Q> = Store<Q>>\nimplements RDF.Source<Q>, RDF.Sink<RDF.Stream<Q>, EventEmitter> {\n  protected readonly store: S;\n  protected readonly pendingStreams: PendingStreamsIndex<Q> = new PendingStreamsIndex();\n  protected ended = false;\n\n  public constructor(store: RDF.Store<Q> = new Store<Q>()) {\n    this.store = <S> store;\n  }\n\n  /**\n   * Mark this store as ended.\n   *\n   * This will make sure that all running and future `match` calls will end,\n   * and all next `import` calls to this store will throw an error.\n   */\n  public end(): void {\n    this.ended = true;\n\n    // Mark all pendingStreams as ended.\n    for (const pendingStream of this.pendingStreams.allStreams) {\n      pendingStream.push(null);\n      (<any> pendingStream)._pipeSource.unpipe();\n    }\n  }\n\n  protected importToListeners(stream: RDF.Stream<Q>): void {\n    stream.on('data', (quad: Q) => {\n      for (const pendingStream of this.pendingStreams.getPendingStreamsForQuad(quad)) {\n        if (!this.ended) {\n          pendingStream.push(quad);\n        }\n      }\n    });\n  }\n\n  public import(stream: RDF.Stream<Q>): EventEmitter {\n    if (this.ended) {\n      throw new Error('Attempted to import into an ended StreamingStore');\n    }\n\n    this.importToListeners(stream);\n    return this.store.import(stream);\n  }\n\n  public match(\n    subject?: RDF.Term | null,\n    predicate?: RDF.Term | null,\n    object?: RDF.Term | null,\n    graph?: RDF.Term | null,\n  ): RDF.Stream<Q> {\n    const storeResult: Readable = <Readable> this.store.match(subject, predicate, object, graph);\n    let stream: RDF.Stream<Q> = storeResult;\n\n    // If the store hasn't ended yet, also create a new pendingStream\n    if (!this.ended) {\n      // The new pendingStream remains open, until the store is ended.\n      const pendingStream = new PassThrough({ objectMode: true });\n      this.pendingStreams.addPatternListener(pendingStream, subject, predicate, object, graph);\n      stream = storeResult.pipe(pendingStream, { end: false });\n      (<any> stream)._pipeSource = storeResult;\n    }\n    return stream;\n  }\n\n  /**\n   * The internal store with all imported quads.\n   */\n  public getStore(): S {\n    return this.store;\n  }\n}\n\n"]}