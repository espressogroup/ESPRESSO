"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamingStore = void 0;
const n3_1 = require("n3");
const readable_stream_1 = require("readable-stream");
const PendingStreamsIndex_1 = require("./PendingStreamsIndex");
/**
 * A StreamingStore allows data lookup and insertion to happen in parallel.
 * Concretely, this means that `match()` calls happening before `import()` calls, will still consider those triples that
 * are inserted later, which is done by keeping the response streams of `match()` open.
 * Only when the `end()` method is invoked, all response streams will close, and the StreamingStore will be considered
 * immutable.
 *
 * WARNING: `end()` MUST be called at some point, otherwise all `match` streams will remain unended.
 */
class StreamingStore {
    constructor(store = new n3_1.Store()) {
        this.pendingStreams = new PendingStreamsIndex_1.PendingStreamsIndex();
        this.ended = false;
        this.store = store;
    }
    /**
     * Mark this store as ended.
     *
     * This will make sure that all running and future `match` calls will end,
     * and all next `import` calls to this store will throw an error.
     */
    end() {
        this.ended = true;
        // Mark all pendingStreams as ended.
        for (const pendingStream of this.pendingStreams.allStreams) {
            pendingStream.push(null);
            pendingStream._pipeSource.unpipe();
        }
    }
    importToListeners(stream) {
        stream.on('data', (quad) => {
            for (const pendingStream of this.pendingStreams.getPendingStreamsForQuad(quad)) {
                if (!this.ended) {
                    pendingStream.push(quad);
                }
            }
        });
    }
    import(stream) {
        if (this.ended) {
            throw new Error('Attempted to import into an ended StreamingStore');
        }
        this.importToListeners(stream);
        return this.store.import(stream);
    }
    match(subject, predicate, object, graph) {
        const storeResult = this.store.match(subject, predicate, object, graph);
        let stream = storeResult;
        // If the store hasn't ended yet, also create a new pendingStream
        if (!this.ended) {
            // The new pendingStream remains open, until the store is ended.
            const pendingStream = new readable_stream_1.PassThrough({ objectMode: true });
            this.pendingStreams.addPatternListener(pendingStream, subject, predicate, object, graph);
            stream = storeResult.pipe(pendingStream, { end: false });
            stream._pipeSource = storeResult;
        }
        return stream;
    }
    /**
     * The internal store with all imported quads.
     */
    getStore() {
        return this.store;
    }
}
exports.StreamingStore = StreamingStore;
//# sourceMappingURL=StreamingStore.js.map