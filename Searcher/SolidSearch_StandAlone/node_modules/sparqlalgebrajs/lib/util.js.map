{"version":3,"file":"util.js","sourceRoot":"","sources":["util.ts"],"names":[],"mappings":"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","sourcesContent":["import { Wildcard } from 'sparqljs';\nimport * as A from \"./algebra\";\nimport { Expression, Operation, expressionTypes, types, TypedOperation } from './algebra';\nimport Factory from \"./factory\";\nimport { BaseQuad, Variable } from '@rdfjs/types';\nimport * as RDF from '@rdfjs/types'\n\n\nexport default class Util\n{\n    /**\n     * Flattens an array of arrays to an array.\n     * @param arr - Array of arrays\n     */\n    public static flatten<T>(arr: T[][]): T[]\n    {\n        return Array.prototype.concat(...arr).filter(x => x);\n    }\n\n    /**\n     * Outputs a JSON object corresponding to the input algebra-like.\n     */\n    public static objectify (algebra: any): any\n    {\n        if (algebra.termType)\n        {\n            if (algebra.termType === 'Quad') {\n                return {\n                    type: 'pattern',\n                    termType: 'Quad',\n                    subject: Util.objectify(algebra.subject),\n                    predicate: Util.objectify(algebra.predicate),\n                    object: Util.objectify(algebra.object),\n                    graph: Util.objectify(algebra.graph),\n                }\n            } else {\n                let result: any = {termType: algebra.termType, value: algebra.value};\n                if (algebra.language)\n                    result.language = algebra.language;\n                if (algebra.datatype)\n                    result.datatype = Util.objectify(algebra.datatype);\n                return result;\n            }\n        }\n        if (Array.isArray(algebra))\n            return algebra.map(e => Util.objectify(e));\n        if (algebra === Object(algebra))\n        {\n            let result: any = {};\n            for (let key of Object.keys(algebra))\n                result[key] = Util.objectify(algebra[key]);\n            return result;\n        }\n        return algebra;\n    }\n\n    /**\n     * Detects all in-scope variables.\n     * In practice this means iterating through the entire algebra tree, finding all variables,\n     * and stopping when a project function is found.\n     * @param {Operation} op - Input algebra tree.\n     * @returns {Variable[]} - List of unique in-scope variables.\n     */\n    public static inScopeVariables(op: A.Operation): Variable[]\n    {\n        const variables: Variable[] = [];\n\n        function addVariable(v: Variable)\n        {\n            if (!variables.find(v2 => v.value === v2.value))\n                variables.push(v);\n        }\n\n        function recurseTerm(quad: BaseQuad) {\n            if (quad.subject.termType === 'Variable')\n                addVariable(quad.subject);\n            if (quad.predicate.termType === 'Variable')\n                addVariable(quad.predicate);\n            if (quad.object.termType === 'Variable')\n                addVariable(quad.object);\n            if (quad.graph.termType === 'Variable')\n                addVariable(quad.graph);\n            if (quad.subject.termType === 'Quad')\n                recurseTerm(quad.subject);\n            if (quad.predicate.termType === 'Quad')\n                recurseTerm(quad.predicate);\n            if (quad.object.termType === 'Quad')\n                recurseTerm(quad.object);\n            if (quad.graph.termType === 'Quad')\n                recurseTerm(quad.graph);\n        }\n\n        // https://www.w3.org/TR/sparql11-query/#variableScope\n        Util.recurseOperation(op, {\n            [types.EXPRESSION]: (op) =>\n            {\n                if (op.expressionType === expressionTypes.AGGREGATE && op.variable)\n                {\n                    addVariable(op.variable);\n                }\n                return true;\n            },\n            [types.EXTEND]: (op) =>\n            {\n                addVariable(op.variable);\n                return true;\n            },\n            [types.GRAPH]: (op) =>\n            {\n                if (op.name.termType === 'Variable')\n                    addVariable(<Variable> op.name);\n                return true;\n            },\n            [types.GROUP]: (op) =>\n            {\n                op.variables.forEach(addVariable);\n                return true;\n            },\n            [types.PATH]: (op) =>\n            {\n                if (op.subject.termType === 'Variable')\n                    addVariable(op.subject);\n                if (op.object.termType === 'Variable')\n                    addVariable(op.object);\n                if (op.graph.termType === 'Variable')\n                    addVariable(op.graph);\n                if (op.subject.termType === 'Quad')\n                    recurseTerm(op.subject);\n                if (op.object.termType === 'Quad')\n                    recurseTerm(op.object);\n                if (op.graph.termType === 'Quad')\n                    recurseTerm(op.graph);\n                return true;\n            },\n            [types.PATTERN]: (op) =>\n            {\n                recurseTerm(op);\n                return true;\n            },\n            [types.PROJECT]: (op) =>\n            {\n                op.variables.forEach(addVariable);\n                return false;\n            },\n            [types.SERVICE]: (op) =>\n            {\n                if (op.name.termType === 'Variable')\n                    addVariable(<Variable> op.name);\n                return true;\n            },\n            [types.VALUES]: (op) =>\n            {\n                op.variables.forEach(addVariable);\n                return true;\n            },\n        });\n\n        return variables;\n    }\n    /**\n     * Recurses through the given algebra tree\n     * A map of callback functions can be provided for individual Operation types to gather data.\n     * The return value of those callbacks should indicate whether recursion should be applied or not.\n     * Making modifications will change the original input object.\n     * @param {Operation} op - The Operation to recurse on.\n     * @param { [type: string]: (op: Operation) => boolean } callbacks - A map of required callback Operations.\n     */\n    public static recurseOperation(op: A.Operation, callbacks:{ [T in A.types]?: (op: TypedOperation<T>,) => boolean }): void\n    {\n        let result: A.Operation = op;\n        let doRecursion = true;\n\n        const callback = callbacks[op.type];\n        if (callback)\n            // Not sure how to get typing correct for op here\n            doRecursion = callback(op as any);\n\n        if (!doRecursion)\n            return;\n\n        let recurseOp = (op: A.Operation) => Util.recurseOperation(op, callbacks);\n\n        switch (result.type)\n        {\n            case types.ALT:\n                result.input.map(recurseOp);\n                break;\n            case types.ASK:\n               recurseOp(result.input);\n               break;\n            case types.BGP:\n                result.patterns.forEach(recurseOp);\n                break;\n            case types.CONSTRUCT:\n                recurseOp(result.input);\n                result.template.map(recurseOp);\n                break;\n            case types.DESCRIBE:\n                recurseOp(result.input);\n                break;\n            case types.DISTINCT:\n                recurseOp(result.input);\n                break;\n            case types.EXPRESSION:\n                if (result.expressionType === expressionTypes.EXISTENCE)\n                {\n                    recurseOp(result.input);\n                }\n                break;\n            case types.EXTEND:\n                recurseOp(result.input);\n                recurseOp(result.expression);\n                break;\n            case types.FILTER:\n                recurseOp(result.input);\n                recurseOp(result.expression);\n                break;\n            case types.FROM:\n                recurseOp(result.input);\n                break;\n            case types.GRAPH:\n                recurseOp(result.input);\n                break;\n            case types.GROUP:\n                recurseOp(result.input);\n                result.aggregates.forEach(recurseOp);\n                break;\n            case types.INV:\n                recurseOp(result.path);\n                break;\n            case types.JOIN:\n                result.input.map(recurseOp);\n                break;\n            case types.LEFT_JOIN:\n                result.input.map(recurseOp);\n                if (result.expression) recurseOp(result.expression);\n                break;\n            case types.LINK:\n                break;\n            case types.MINUS:\n                result.input.map(recurseOp);\n                break;\n            case types.NOP:\n                break;\n            case types.NPS:\n                break;\n            case types.ONE_OR_MORE_PATH:\n                recurseOp(result.path);\n                break;\n            case types.ORDER_BY:\n                recurseOp(result.input);\n                result.expressions.forEach(recurseOp);\n                break;\n            case types.PATH:\n                recurseOp(result.predicate);\n                break;\n            case types.PATTERN:\n                break;\n            case types.PROJECT:\n                recurseOp(result.input);\n                break;\n            case types.REDUCED:\n                recurseOp(result.input);\n                break;\n            case types.SEQ:\n                result.input.map(recurseOp);\n                break;\n            case types.SERVICE:\n                recurseOp(result.input);\n                break;\n            case types.SLICE:\n                recurseOp(result.input);\n                break;\n            case types.UNION:\n                result.input.map(recurseOp);\n                break;\n            case types.VALUES:\n                break;\n            case types.ZERO_OR_MORE_PATH:\n                recurseOp(result.path);\n                break;\n            case types.ZERO_OR_ONE_PATH:\n                recurseOp(result.path);\n                break;\n            // UPDATE operations\n            case types.COMPOSITE_UPDATE:\n                result.updates.forEach(update => recurseOp(update));\n                break;\n            case types.DELETE_INSERT:\n                if (result.delete)\n                    result.delete.forEach(pattern => recurseOp(pattern));\n                if (result.insert)\n                    result.insert.forEach(pattern => recurseOp(pattern));\n                if (result.where)\n                    recurseOp(result.where);\n                break;\n            // all of these only have graph IDs as values\n            case types.LOAD: break;\n            case types.CLEAR: break;\n            case types.CREATE: break;\n            case types.DROP: break;\n            case types.ADD: break;\n            case types.MOVE: break;\n            case types.COPY: break;\n            default: throw new Error(`Unknown Operation type ${(result as any).type}`);\n        }\n    }\n\n    /**\n     * Creates a deep copy of the given Operation.\n     * Creates shallow copies of the non-Operation values.\n     * A map of callback functions can be provided for individual Operation types\n     * to specifically modify the given objects before triggering recursion.\n     * The return value of those callbacks should indicate whether recursion should be applied to this returned object or not.\n     * @param {Operation} op - The Operation to recurse on.\n     * @param { [type: string]: (op: Operation, factory: Factory) => RecurseResult } callbacks - A map of required callback Operations.\n     * @param {Factory} factory - Factory used to create new Operations. Will use default factory if none is provided.\n     * @returns {Operation} - The copied result.\n     */\n    public static mapOperation(op: A.Operation,\n      callbacks:{ [T in A.types]?: (op: TypedOperation<T>, factory: Factory) => RecurseResult },\n      factory?: Factory): A.Operation\n    {\n        let result: A.Operation = op;\n        let doRecursion = true;\n\n        factory = factory || new Factory();\n\n        const callback = callbacks[op.type];\n        if (callback)\n            // Not sure how to get typing correct for op here\n            ({ result, recurse: doRecursion } = callback(op as any, factory));\n\n        if (!doRecursion)\n            return result;\n\n        let mapOp = (op: A.Operation) => Util.mapOperation(op, callbacks, factory);\n\n        // Several casts here might be wrong though depending on the callbacks output\n        switch (result.type)\n        {\n            case types.ALT:\n                return factory.createAlt(<A.PropertyPathSymbol[]> result.input.map(mapOp));\n            case types.ASK:\n                return factory.createAsk(mapOp(result.input));\n            case types.BGP:\n                return factory.createBgp(<A.Pattern[]> result.patterns.map(mapOp));\n            case types.CONSTRUCT:\n                return factory.createConstruct(mapOp(result.input), <A.Pattern[]> result.template.map(mapOp));\n            case types.DESCRIBE:\n                return factory.createDescribe(mapOp(result.input), result.terms);\n            case types.DISTINCT:\n                return factory.createDistinct(mapOp(result.input));\n            case types.EXPRESSION:\n                return Util.mapExpression(result, callbacks, factory);\n            case types.EXTEND:\n                return factory.createExtend(mapOp(result.input), result.variable, <A.Expression> mapOp(result.expression));\n            case types.FILTER:\n                return factory.createFilter(mapOp(result.input), <A.Expression> mapOp(result.expression));\n            case types.FROM:\n                return factory.createFrom(mapOp(result.input), [ ...result.default ], [ ...result.named ]);\n            case types.GRAPH:\n                return factory.createGraph(mapOp(result.input), result.name);\n            case types.GROUP:\n                return factory.createGroup(\n                    mapOp(result.input),\n                    (<RDF.Variable[]>[]).concat(result.variables),\n                    <A.BoundAggregate[]> result.aggregates.map(mapOp));\n            case types.INV:\n                return factory.createInv(<A.PropertyPathSymbol> mapOp(result.path));\n            case types.JOIN:\n                return factory.createJoin(result.input.map(mapOp));\n            case types.LEFT_JOIN:\n                return factory.createLeftJoin(\n                    mapOp(result.input[0]),\n                    mapOp(result.input[1]),\n                  result.expression ? <A.Expression> mapOp(result.expression) : undefined);\n            case types.LINK:\n                return factory.createLink(result.iri);\n            case types.MINUS:\n                return factory.createMinus(mapOp(result.input[0]), mapOp(result.input[1]));\n            case types.NOP:\n                return factory.createNop();\n            case types.NPS:\n                return factory.createNps((<RDF.NamedNode[]>[]).concat(result.iris));\n            case types.ONE_OR_MORE_PATH:\n                return factory.createOneOrMorePath(<A.PropertyPathSymbol> mapOp(result.path));\n            case types.ORDER_BY:\n                return factory.createOrderBy(mapOp(result.input), <A.Expression[]> result.expressions.map(mapOp));\n            case types.PATH:\n                return factory.createPath(result.subject, <A.PropertyPathSymbol> mapOp(result.predicate), result.object, result.graph);\n            case types.PATTERN:\n                return factory.createPattern(result.subject, result.predicate, result.object, result.graph);\n            case types.PROJECT:\n                return factory.createProject(mapOp(result.input), [ ...result.variables ]);\n            case types.REDUCED:\n                return factory.createReduced(mapOp(result.input));\n            case types.SEQ:\n                return factory.createSeq(<A.PropertyPathSymbol[]> result.input.map(mapOp));\n            case types.SERVICE:\n                return factory.createService(mapOp(result.input), result.name, result.silent);\n            case types.SLICE:\n                return factory.createSlice(mapOp(result.input), result.start, result.length);\n            case types.UNION:\n                return factory.createUnion(result.input.map(mapOp));\n            case types.VALUES:\n                return factory.createValues((<RDF.Variable[]>[]).concat(result.variables), result.bindings.map(b => Object.assign({}, b)));\n            case types.ZERO_OR_MORE_PATH:\n                return factory.createZeroOrMorePath(<A.PropertyPathSymbol> mapOp(result.path));\n            case types.ZERO_OR_ONE_PATH:\n                return factory.createZeroOrOnePath(<A.PropertyPathSymbol> mapOp(result.path));\n          // UPDATE operations\n            case types.COMPOSITE_UPDATE:\n                return factory.createCompositeUpdate(<A.Update[]> result.updates.map(mapOp));\n            case types.DELETE_INSERT:\n                return factory.createDeleteInsert(\n                  result.delete ? <A.Pattern[]> result.delete.map(mapOp) : undefined,\n                  result.insert ? <A.Pattern[]> result.insert.map(mapOp) : undefined,\n                  result.where ? mapOp(result.where) : undefined,\n                  );\n            case types.LOAD:\n                return factory.createLoad(result.source, result.destination, result.silent);\n            case types.CLEAR:\n                return factory.createClear(result.source, result.silent);\n            case types.CREATE:\n                return factory.createCreate(result.source, result.silent);\n            case types.DROP:\n                return factory.createDrop(result.source, result.silent);\n            case types.ADD:\n                return factory.createAdd(result.source, result.destination);\n            case types.MOVE:\n                return factory.createMove(result.source, result.destination);\n            case types.COPY:\n                return factory.createCopy(result.source, result.destination);\n            default: throw new Error(`Unknown Operation type ${(result as any).type}`);\n        }\n    }\n\n    /**\n     * Similar to the {@link mapOperation} function but specifically for expressions.\n     * Both functions call each other while copying.\n     * Should not be called directly since it does not execute the callbacks, these happen in {@link mapOperation}.\n     * @param {Expression} expr - The Operation to recurse on.\n     * @param { [type: string]: (op: Operation, factory: Factory) => RecurseResult } callbacks - A map of required callback Operations.\n     * @param {Factory} factory - Factory used to create new Operations. Will use default factory if none is provided.\n     * @returns {Operation} - The copied result.\n     */\n    private static mapExpression(expr: A.Expression,\n      callbacks:{ [T in A.types]?: (op: TypedOperation<T>, factory: Factory) => RecurseResult },\n      factory: Factory): A.Expression\n    {\n        let recurse = (op: A.Operation) => Util.mapOperation(op, callbacks, factory);\n\n        switch(expr.expressionType)\n        {\n            case expressionTypes.AGGREGATE:\n                if (expr.variable)\n                {\n                    return factory.createBoundAggregate(expr.variable, expr.aggregator, <Expression> recurse(expr.expression), expr.distinct, expr.separator);\n                }\n                return factory.createAggregateExpression(expr.aggregator, <Expression> recurse(expr.expression), expr.distinct, expr.separator);\n            case expressionTypes.EXISTENCE:\n                return factory.createExistenceExpression(expr.not, recurse(expr.input));\n            case expressionTypes.NAMED:\n                return factory.createNamedExpression(expr.name, <A.Expression[]> expr.args.map(recurse));\n            case expressionTypes.OPERATOR:\n                return factory.createOperatorExpression(expr.operator, <A.Expression[]> expr.args.map(recurse));\n            case expressionTypes.TERM:\n                return factory.createTermExpression(expr.term);\n            case expressionTypes.WILDCARD:\n                return factory.createWildcardExpression();\n            default: throw new Error(`Unknown Expression type ${(expr as any).expressionType}`);\n        }\n    }\n\n    public static createUniqueVariable(label: string, variables: {[vLabel: string]: boolean}, dataFactory: RDF.DataFactory<BaseQuad, BaseQuad>): RDF.Variable {\n        let counter: number = 0;\n        let labelLoop = label;\n        while (variables[labelLoop]) {\n            labelLoop = `${label}${counter++}`;\n        }\n        return dataFactory.variable!(labelLoop);\n    }\n\n    // separate terms from wildcard since we handle them differently\n    public static isSimpleTerm(term: any): term is RDF.Term {\n        return term.termType !== undefined && term.termType !== 'Quad' && term.termType !== 'Wildcard';\n    }\n\n    public static isQuad(term: any): term is RDF.Quad {\n        return term.termType === 'Quad';\n    }\n\n    public static isWildcard(term: any): term is Wildcard {\n        return term.termType === 'Wildcard';\n    }\n}\n\n/**\n * @interface RecurseResult\n * @property {Operation} result - The resulting A.Operation.\n * @property {boolean} recurse - Whether to continue with recursion.\n */\nexport interface RecurseResult\n{\n    result: A.Operation;\n    recurse: boolean;\n}\n"]}