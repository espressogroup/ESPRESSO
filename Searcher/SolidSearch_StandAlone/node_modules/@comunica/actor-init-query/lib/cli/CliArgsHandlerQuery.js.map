{"version":3,"file":"CliArgsHandlerQuery.js","sourceRoot":"","sources":["CliArgsHandlerQuery.ts"],"names":[],"mappings":"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","sourcesContent":["import { ProxyHandlerStatic } from '@comunica/actor-http-proxy';\nimport {\n  KeysHttpMemento,\n  KeysHttpProxy,\n  KeysHttpWayback,\n  KeysInitQuery,\n  KeysQueryOperation,\n} from '@comunica/context-entries';\nimport type { ICliArgsHandler } from '@comunica/types';\nimport type { Argv } from 'yargs';\n\n/**\n * CLI arguments handler that handles options for query execution.\n */\nexport class CliArgsHandlerQuery implements ICliArgsHandler {\n  private readonly defaultQueryInputFormat: string | undefined;\n  private readonly queryString: string | undefined;\n  private readonly context: string | undefined;\n  private readonly allowNoSources: boolean | undefined;\n\n  public constructor(\n    defaultQueryInputFormat: string | undefined,\n    queryString: string | undefined,\n    context: string | undefined,\n    allowNoSources: boolean | undefined,\n  ) {\n    this.defaultQueryInputFormat = defaultQueryInputFormat;\n    this.queryString = queryString;\n    this.context = context;\n    this.allowNoSources = allowNoSources;\n  }\n\n  public populateYargs(argumentsBuilder: Argv<any>): Argv<any> {\n    return argumentsBuilder\n      .usage('$0 evaluates SPARQL queries')\n      .example([\n        [ `$0 https://fragments.dbpedia.org/2016-04/en -q 'SELECT * { ?s ?p ?o }'`, '' ],\n        [ `$0 https://fragments.dbpedia.org/2016-04/en -f query.sparql`, '' ],\n        [ `$0 https://fragments.dbpedia.org/2016-04/en https://query.wikidata.org/sparql ...`, '' ],\n        [ `$0 hypermedia@https://fragments.dbpedia.org/2016-04/en sparql@https://query.wikidata.org/sparql ...`, '' ],\n      ])\n      .options({\n        query: {\n          alias: 'q',\n          type: 'string',\n          describe: 'Evaluate the given SPARQL query string',\n          default: this.queryString,\n          group: 'Recommended options:',\n        },\n        file: {\n          alias: 'f',\n          type: 'string',\n          describe: 'Evaluate the SPARQL query in the given file',\n          group: 'Recommended options:',\n        },\n        inputType: {\n          alias: 'i',\n          type: 'string',\n          describe: 'Query input format (e.g., graphql, sparql)',\n          default: this.defaultQueryInputFormat,\n          group: 'Recommended options:',\n        },\n        outputType: {\n          alias: 't',\n          type: 'string',\n          describe: 'MIME type of the output (e.g., application/json)',\n          group: 'Recommended options:',\n        },\n        proxy: {\n          alias: 'p',\n          type: 'string',\n          describe: 'Delegates all HTTP traffic through the given proxy (e.g. http://myproxy.org/?uri=)',\n        },\n        listformats: {\n          type: 'boolean',\n          describe: 'Prints the supported MIME types',\n        },\n        context: {\n          type: 'string',\n          describe: 'Use the given JSON context string or file (e.g., config.json)',\n          default: this.context,\n        },\n        explain: {\n          type: 'string',\n          describe: 'Print the query plan',\n          choices: [\n            'parsed',\n            'logical',\n            'physical',\n          ],\n        },\n        localizeBlankNodes: {\n          type: 'boolean',\n          describe: 'If blank nodes should be localized per bindings entry',\n        },\n        recoverBrokenLinks: {\n          alias: 'r',\n          type: 'boolean',\n          describe: 'Use the WayBack machine to recover broken links',\n          default: false,\n        },\n      })\n      .check(args => {\n        if (args.version || args.listformats) {\n          return true;\n        }\n        if (this.allowNoSources) {\n          if (!this.queryString && !(args.query || args.file) && args.sources.length === 0) {\n            throw new Error('A query must be provided');\n          }\n        } else if (!this.queryString ?\n          !(args.query || args.file) && args.sources.length < (args.context ? 1 : 2) :\n          args.sources.length < (args.context ? 0 : 1)) {\n          throw new Error('At least one source and query must be provided');\n        }\n        return true;\n      });\n  }\n\n  public async handleArgs(args: Record<string, any>, context: Record<string, any>): Promise<void> {\n    // Define the query format\n    context[KeysInitQuery.queryFormat.name] = { language: args.inputType, version: '1.1' };\n\n    // Define the datetime\n    if (args.dateTime) {\n      context[KeysHttpMemento.datetime.name] = new Date(args.dateTime);\n    }\n\n    // Set the proxy\n    if (args.proxy) {\n      context[KeysHttpProxy.httpProxyHandler.name] = new ProxyHandlerStatic(args.proxy);\n    }\n\n    // Mark explain output\n    if (args.explain) {\n      context[KeysInitQuery.explain.name] = args.explain;\n    }\n\n    // Set the blank node localization\n    if (args.localizeBlankNodes) {\n      context[KeysQueryOperation.localizeBlankNodes.name] = args.localizeBlankNodes;\n    }\n\n    // Set recover broken links flag\n    if (args.recoverBrokenLinks) {\n      context[KeysHttpWayback.recoverBrokenLinks.name] = args.recoverBrokenLinks;\n    }\n  }\n}\n"]}