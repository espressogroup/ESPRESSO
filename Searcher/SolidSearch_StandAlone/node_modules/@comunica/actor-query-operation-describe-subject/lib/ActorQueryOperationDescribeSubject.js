"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActorQueryOperationDescribeSubject = void 0;
const actor_query_operation_union_1 = require("@comunica/actor-query-operation-union");
const bus_query_operation_1 = require("@comunica/bus-query-operation");
const context_entries_1 = require("@comunica/context-entries");
const asynciterator_1 = require("asynciterator");
const rdf_data_factory_1 = require("rdf-data-factory");
const sparqlalgebrajs_1 = require("sparqlalgebrajs");
const DF = new rdf_data_factory_1.DataFactory();
/**
 * A comunica Describe Subject Query Operation Actor.
 */
class ActorQueryOperationDescribeSubject extends bus_query_operation_1.ActorQueryOperationTypedMediated {
    constructor(args) {
        super(args, 'describe');
    }
    async testOperation(operation, context) {
        return true;
    }
    async runOperation(operationOriginal, context) {
        // Create separate construct queries for all non-variable terms
        const operations = operationOriginal.terms
            .filter(term => term.termType !== 'Variable')
            .map((term) => {
            // Transform each term to a separate construct operation with S ?p ?o patterns (BGP) for all terms
            const patterns = [
                DF.quad(term, DF.variable('__predicate'), DF.variable('__object')),
            ];
            // eslint-disable-next-line no-return-assign
            patterns.forEach((templatePattern) => templatePattern.type = 'pattern');
            const templateOperation = {
                type: sparqlalgebrajs_1.Algebra.types.BGP,
                patterns: patterns,
            };
            // Create a construct query
            return {
                input: templateOperation,
                template: patterns,
                type: 'construct',
            };
        });
        // If we have variables in the term list,
        // create one separate construct operation to determine these variables using the input pattern.
        if (operations.length !== operationOriginal.terms.length) {
            let variablePatterns = [];
            operationOriginal.terms
                .filter(term => term.termType === 'Variable')
                .forEach((term, i) => {
                // Transform each term to an S ?p ?o pattern in a non-conflicting way
                const patterns = [
                    DF.quad(term, DF.variable(`__predicate${i}`), DF.variable(`__object${i}`)),
                ];
                // eslint-disable-next-line no-return-assign
                patterns.forEach((templatePattern) => templatePattern.type = 'pattern');
                variablePatterns = [...variablePatterns, ...patterns];
            });
            // Add a single construct for the variables
            // This requires a join between the input pattern and our variable patterns that form a simple BGP
            operations.push({
                input: {
                    type: sparqlalgebrajs_1.Algebra.types.JOIN,
                    input: [
                        operationOriginal.input,
                        { type: sparqlalgebrajs_1.Algebra.types.BGP, patterns: variablePatterns },
                    ],
                },
                template: variablePatterns,
                type: sparqlalgebrajs_1.Algebra.types.CONSTRUCT,
            });
        }
        // Set the blank node localization
        // If it was not provided by the context it will set to false and added into the context
        const localizeBlankNode = context.get(context_entries_1.KeysQueryOperation.localizeBlankNodes);
        context = context.set(context_entries_1.KeysQueryOperation.localizeBlankNodes, localizeBlankNode !== undefined ?
            localizeBlankNode :
            false);
        // Evaluate the construct queries
        const outputs = (await Promise.all(operations.map(operation => this.mediatorQueryOperation.mediate({ operation, context }))))
            .map(bus_query_operation_1.ActorQueryOperation.getSafeQuads);
        // Take the union of all quad streams
        const quadStream = new asynciterator_1.UnionIterator(outputs.map(output => output.quadStream), { autoStart: false });
        // Take union of metadata
        const metadata = () => Promise.all(outputs
            .map(x => x.metadata()))
            .then(metadatas => actor_query_operation_union_1.ActorQueryOperationUnion.unionMetadata(metadatas, false));
        return { type: 'quads', quadStream, metadata };
    }
}
exports.ActorQueryOperationDescribeSubject = ActorQueryOperationDescribeSubject;
//# sourceMappingURL=ActorQueryOperationDescribeSubject.js.map