"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActorQueryOperationConstruct = void 0;
const bus_query_operation_1 = require("@comunica/bus-query-operation");
const context_entries_1 = require("@comunica/context-entries");
const rdf_terms_1 = require("rdf-terms");
const sparqlalgebrajs_1 = require("sparqlalgebrajs");
const BindingsToQuadsIterator_1 = require("./BindingsToQuadsIterator");
/**
 * A comunica Construct Query Operation Actor.
 */
class ActorQueryOperationConstruct extends bus_query_operation_1.ActorQueryOperationTypedMediated {
    constructor(args) {
        super(args, 'construct');
    }
    /**
     * Find all variables in a list of triple patterns.
     * @param {Algebra.Pattern[]} patterns An array of triple patterns.
     * @return {RDF.Variable[]} The variables in the triple patterns.
     */
    static getVariables(patterns) {
        return (0, rdf_terms_1.uniqTerms)([].concat
            .apply([], patterns.map(pattern => (0, rdf_terms_1.getVariables)((0, rdf_terms_1.getTerms)(pattern)))));
    }
    async testOperation(operation, context) {
        return true;
    }
    async runOperation(operationOriginal, context) {
        // Apply a projection on our CONSTRUCT variables first, as the query may contain other variables as well.
        const variables = ActorQueryOperationConstruct.getVariables(operationOriginal.template);
        const operation = { type: sparqlalgebrajs_1.Algebra.types.PROJECT, input: operationOriginal.input, variables };
        // Evaluate the input query
        const output = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({ operation, context }));
        // Check if we apply blank node localization.
        // The context dictate it's application.
        // If it is not provided will apply the localization by default.
        const localizeBlankNodesFromContext = context.get(context_entries_1.KeysQueryOperation.localizeBlankNodes);
        const localizeBlankNodes = localizeBlankNodesFromContext !== undefined ?
            localizeBlankNodesFromContext :
            true;
        // Construct triples using the result based on the pattern.
        // If it's a DESCRIBE query don't apply the blank node localisation.
        const quadStream = new BindingsToQuadsIterator_1.BindingsToQuadsIterator(operationOriginal.template, output.bindingsStream, localizeBlankNodes);
        // Let the final metadata contain the estimated number of triples
        const metadata = () => output.metadata().then(meta => ({
            ...meta,
            order: undefined,
            cardinality: {
                type: meta.cardinality.type,
                value: meta.cardinality.value * operationOriginal.template.length,
            },
            canContainUndefs: false,
            availableOrders: undefined,
        }));
        return {
            metadata,
            quadStream,
            type: 'quads',
        };
    }
}
exports.ActorQueryOperationConstruct = ActorQueryOperationConstruct;
//# sourceMappingURL=ActorQueryOperationConstruct.js.map