{"version":3,"file":"TypeHandling.js","sourceRoot":"","sources":["../../../lib/util/TypeHandling.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as LRUCache from 'lru-cache';\nimport type { TermType } from '../expressions';\nimport { asTermType } from '../expressions';\nimport type { KnownLiteralTypes } from './Consts';\nimport { TypeAlias, TypeURL } from './Consts';\n\nexport type OverrideType = KnownLiteralTypes | 'term';\n\n/**\n * Types that are not mentioned just map to 'term'.\n * When editing this, make sure type promotion and substituion don't start interfering.\n * e.g. when saying something like string -> stringly -> anyUri -> term.\n * This would make substitution on types that promote to each other possible. We and the specs don't want that!\n * A DAG will be created based on this. Make sure it doesn't have any cycles!\n */\nexport const extensionTableInput: Record<KnownLiteralTypes, OverrideType> = {\n  // Datetime types\n  [TypeURL.XSD_DATE_TIME_STAMP]: TypeURL.XSD_DATE_TIME,\n\n  // Duration types\n  [TypeURL.XSD_DAYTIME_DURATION]: TypeURL.XSD_DURATION,\n  [TypeURL.XSD_YEAR_MONTH_DURATION]: TypeURL.XSD_DURATION,\n\n  // Stringly types\n  [TypeURL.RDF_LANG_STRING]: TypeAlias.SPARQL_STRINGLY,\n  [TypeURL.XSD_STRING]: TypeAlias.SPARQL_STRINGLY,\n\n  // String types\n  [TypeURL.XSD_NORMALIZED_STRING]: TypeURL.XSD_STRING,\n  [TypeURL.XSD_TOKEN]: TypeURL.XSD_NORMALIZED_STRING,\n  [TypeURL.XSD_LANGUAGE]: TypeURL.XSD_TOKEN,\n  [TypeURL.XSD_NM_TOKEN]: TypeURL.XSD_TOKEN,\n  [TypeURL.XSD_NAME]: TypeURL.XSD_TOKEN,\n  [TypeURL.XSD_NC_NAME]: TypeURL.XSD_NAME,\n  [TypeURL.XSD_ENTITY]: TypeURL.XSD_NC_NAME,\n  [TypeURL.XSD_ID]: TypeURL.XSD_NC_NAME,\n  [TypeURL.XSD_ID_REF]: TypeURL.XSD_NC_NAME,\n\n  // Numeric types\n  // https://www.w3.org/TR/sparql11-query/#operandDataTypes\n  // > numeric denotes typed literals with datatypes xsd:integer, xsd:decimal, xsd:float, and xsd:double\n  [TypeURL.XSD_DOUBLE]: TypeAlias.SPARQL_NUMERIC,\n  [TypeURL.XSD_FLOAT]: TypeAlias.SPARQL_NUMERIC,\n  [TypeURL.XSD_DECIMAL]: TypeAlias.SPARQL_NUMERIC,\n\n  // Decimal types\n  [TypeURL.XSD_INTEGER]: TypeURL.XSD_DECIMAL,\n\n  [TypeURL.XSD_NON_POSITIVE_INTEGER]: TypeURL.XSD_INTEGER,\n  [TypeURL.XSD_NEGATIVE_INTEGER]: TypeURL.XSD_NON_POSITIVE_INTEGER,\n\n  [TypeURL.XSD_LONG]: TypeURL.XSD_INTEGER,\n  [TypeURL.XSD_INT]: TypeURL.XSD_LONG,\n  [TypeURL.XSD_SHORT]: TypeURL.XSD_INT,\n  [TypeURL.XSD_BYTE]: TypeURL.XSD_SHORT,\n\n  [TypeURL.XSD_NON_NEGATIVE_INTEGER]: TypeURL.XSD_INTEGER,\n  [TypeURL.XSD_POSITIVE_INTEGER]: TypeURL.XSD_NON_NEGATIVE_INTEGER,\n  [TypeURL.XSD_UNSIGNED_LONG]: TypeURL.XSD_NON_NEGATIVE_INTEGER,\n  [TypeURL.XSD_UNSIGNED_INT]: TypeURL.XSD_UNSIGNED_LONG,\n  [TypeURL.XSD_UNSIGNED_SHORT]: TypeURL.XSD_UNSIGNED_INT,\n  [TypeURL.XSD_UNSIGNED_BYTE]: TypeURL.XSD_UNSIGNED_SHORT,\n\n  [TypeURL.XSD_DATE_TIME]: 'term',\n  [TypeURL.XSD_BOOLEAN]: 'term',\n  [TypeURL.XSD_DATE]: 'term',\n  [TypeURL.XSD_DURATION]: 'term',\n  [TypeAlias.SPARQL_NUMERIC]: 'term',\n  [TypeAlias.SPARQL_STRINGLY]: 'term',\n  [TypeAlias.SPARQL_NON_LEXICAL]: 'term',\n  [TypeURL.XSD_ANY_URI]: 'term',\n};\ntype SuperTypeDict = Record<KnownLiteralTypes, number> & { __depth: number };\ntype SuperTypeDictTable = Record<KnownLiteralTypes, SuperTypeDict>;\n// The key 'term' is not included in these keys. Something that is just a term will map to number 0.\nexport type GeneralSuperTypeDict = Record<string, number> & { __depth: number };\nexport let superTypeDictTable: SuperTypeDictTable;\n\n/**\n * This will return the super types of a type and cache them.\n * @param type IRI we will decide the super types of.\n * @param openWorldType the enabler that provides a way to find super types.\n */\nexport function getSuperTypes(type: string, openWorldType: ISuperTypeProvider): GeneralSuperTypeDict {\n  const cached = openWorldType.cache.get(type);\n  if (cached) {\n    return cached;\n  }\n  const value = openWorldType.discoverer(type);\n  if (value === 'term') {\n    const res: GeneralSuperTypeDict = Object.create(null);\n    res.__depth = 0;\n    res[type] = 0;\n    openWorldType.cache.set(type, res);\n    return res;\n  }\n  let subExtension: GeneralSuperTypeDict;\n  const knownValue = asKnownLiteralType(value);\n  if (knownValue) {\n    subExtension = { ...superTypeDictTable[knownValue] };\n  } else {\n    subExtension = { ...getSuperTypes(value, openWorldType) };\n  }\n  subExtension.__depth++;\n  subExtension[type] = subExtension.__depth;\n  openWorldType.cache.set(type, subExtension);\n  return subExtension;\n}\n\n// No circular structure allowed! & No other keys allowed!\nexport function extensionTableInit(): void {\n  const res: SuperTypeDictTable = Object.create(null);\n  for (const [ _key, value ] of Object.entries(extensionTableInput)) {\n    const key = <KnownLiteralTypes>_key;\n    if (res[key]) {\n      continue;\n    }\n    extensionTableBuilderInitKey(key, value, res);\n  }\n  superTypeDictTable = res;\n}\nextensionTableInit();\n\nfunction extensionTableBuilderInitKey(key: KnownLiteralTypes, value: OverrideType, res: SuperTypeDictTable): void {\n  if (value === 'term' || value === undefined) {\n    const baseRes: SuperTypeDict = Object.create(null);\n    baseRes.__depth = 0;\n    baseRes[key] = 0;\n    res[key] = baseRes;\n    return;\n  }\n  if (!res[value]) {\n    extensionTableBuilderInitKey(value, extensionTableInput[value], res);\n  }\n  res[key] = { ...res[value], [key]: res[value].__depth + 1, __depth: res[value].__depth + 1 };\n}\n\nexport let typeAliasCheck: Record<TypeAlias, boolean>;\nfunction initTypeAliasCheck(): void {\n  typeAliasCheck = Object.create(null);\n  for (const val of Object.values(TypeAlias)) {\n    typeAliasCheck[val] = true;\n  }\n}\ninitTypeAliasCheck();\n\nexport function asTypeAlias(type: string): TypeAlias | undefined {\n  if (type in typeAliasCheck) {\n    return <TypeAlias> type;\n  }\n  return undefined;\n}\n\nexport function asKnownLiteralType(type: string): KnownLiteralTypes | undefined {\n  if (type in superTypeDictTable) {\n    return <KnownLiteralTypes> type;\n  }\n  return undefined;\n}\n\nexport function asOverrideType(type: string): OverrideType | undefined {\n  if (asKnownLiteralType(type) || type === 'term') {\n    return <OverrideType> type;\n  }\n  return undefined;\n}\n\nexport function asGeneralType(type: string): 'term' | TermType | undefined {\n  if (type === 'term' || asTermType(type)) {\n    return <'term' | TermType> type;\n  }\n  return undefined;\n}\n\nexport type TypeCache = LRUCache<string, GeneralSuperTypeDict>;\nexport type SuperTypeCallback = (unknownType: string) => string;\nexport interface ISuperTypeProvider {\n  cache: TypeCache;\n  discoverer: SuperTypeCallback;\n}\n\n/**\n * Internal type of @see isSubTypeOf This only takes knownTypes but doesn't need an enabler\n */\nexport function isInternalSubType(baseType: OverrideType, argumentType: KnownLiteralTypes): boolean {\n  return baseType !== 'term' &&\n    (superTypeDictTable[baseType] && superTypeDictTable[baseType][argumentType] !== undefined);\n}\n\n/**\n * This function can be used to check the base type is a restriction on a type in the dict.\n * If we want to check if type x is a restriction on string we do this by calling:\n * 'http://www.w3.org/2001/XMLSchema#string' in getSuperTypeDict(X, superTypeProvider)\n * @param baseType\n * @param superTypeProvider\n */\nexport function getSuperTypeDict(baseType: string, superTypeProvider: ISuperTypeProvider): GeneralSuperTypeDict {\n  const concreteType: KnownLiteralTypes | undefined = asKnownLiteralType(baseType);\n  if (concreteType) {\n    // Concrete dataType is known by sparqlee.\n    return superTypeDictTable[concreteType];\n  }\n  // Datatype is a custom datatype\n  return getSuperTypes(baseType, superTypeProvider);\n}\n\n/**\n * This function needs do be O(1)! The execution time of this function is vital!\n * We define typeA isSubtypeOf typeA as true.\n * If you find yourself using this function a lot (e.g. in a case) please use getSuperTypeDict instead.\n * @param baseType type you want to provide.\n * @param argumentType type you want to provide @param baseType to.\n * @param superTypeProvider the enabler to discover super types of unknown types.\n */\nexport function isSubTypeOf(baseType: string, argumentType: KnownLiteralTypes,\n  superTypeProvider: ISuperTypeProvider): boolean {\n  if (baseType === 'term') {\n    return false;\n  }\n  return getSuperTypeDict(baseType, superTypeProvider)[argumentType] !== undefined;\n}\n"]}