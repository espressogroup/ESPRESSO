{"version":3,"file":"BaseAggregator.js","sourceRoot":"","sources":["../../../lib/aggregators/BaseAggregator.ts"],"names":[],"mappings":";;;AAIA,qEAAkE;AAElE,2CAA2C;AAC3C,uDAAmD;AAEnD,MAAsB,cAAc;IAKlC,YAAmB,IAAiC,EAAY,aAAqC;QAArC,kBAAa,GAAb,aAAa,CAAwB;QACnG,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;QAC9B,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,SAAS,IAAI,GAAG,CAAC;QACvC,IAAI,CAAC,eAAe,GAAG,IAAI,iCAAe,CAAC,aAAa,CAAC,iBAAiB,CAAC,CAAC;IAC9E,CAAC;IAES,oBAAoB,CAAC,IAAc;QAC3C,wBAAwB;QACxB,IAAI,IAAI,CAAC,QAAQ,KAAK,SAAS,EAAE;YAC/B,MAAM,IAAI,KAAK,CAAC,mBAAmB,IAAI,CAAC,KAAK,aAAa,IAAI,CAAC,QAAQ,+BAA+B,CAAC,CAAC;SACzG;aAAM,IACL,CAAC,IAAA,0BAAW,EAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,kBAAS,CAAC,cAAc,EAAE,IAAI,CAAC,aAAa,CAAC,iBAAiB,CAAC,EACjG;YACA,MAAM,IAAI,KAAK,CAAC,iBAAiB,IAAI,CAAC,QAAQ,CAAC,KAAK,eAAe,IAAI,CAAC,KAAK,aAAa,IAAI,CAAC,QAAQ,+BAA+B,CAAC,CAAC;SACzI;QACD,OAA0B,IAAI,CAAC,eAAe,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;IACxE,CAAC;IAES,YAAY,CAAC,IAAc;QACnC,IAAI,IAAI,CAAC,QAAQ,KAAK,SAAS,EAAE;YAC/B,MAAM,IAAI,KAAK,CAAC,mBAAmB,IAAI,CAAC,KAAK,aAAa,IAAI,CAAC,QAAQ,uBAAuB,CAAC,CAAC;SACjG;QAED,MAAM,cAAc,GAAG,IAAI,CAAC,eAAe,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;QACnE,OAAO,EAAE,IAAI,EAAE,cAAc,CAAC,QAAQ,EAAE,KAAK,EAAE,cAAc,CAAC,UAAU,EAAE,CAAC;IAC7E,CAAC;IAEM,MAAM,CAAC,UAAU;QACtB,OAAO,SAAS,CAAC;IACnB,CAAC;CAOF;AAzCD,wCAyCC","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport type { Algebra } from 'sparqlalgebrajs';\nimport type { ICompleteSharedContext } from '../evaluators/evaluatorHelpers/BaseExpressionEvaluator';\nimport type * as E from '../expressions';\nimport { TermTransformer } from '../transformers/TermTransformer';\nimport type { ITermTransformer } from '../transformers/TermTransformer';\nimport { TypeAlias } from '../util/Consts';\nimport { isSubTypeOf } from '../util/TypeHandling';\n\nexport abstract class BaseAggregator<State> {\n  protected distinct: boolean;\n  protected separator: string;\n  protected termTransformer: ITermTransformer;\n\n  public constructor(expr: Algebra.AggregateExpression, protected sharedContext: ICompleteSharedContext) {\n    this.distinct = expr.distinct;\n    this.separator = expr.separator || ' ';\n    this.termTransformer = new TermTransformer(sharedContext.superTypeProvider);\n  }\n\n  protected termToNumericOrError(term: RDF.Term): E.NumericLiteral {\n    // TODO: Check behaviour\n    if (term.termType !== 'Literal') {\n      throw new Error(`Term with value ${term.value} has type ${term.termType} and is not a numeric literal`);\n    } else if (\n      !isSubTypeOf(term.datatype.value, TypeAlias.SPARQL_NUMERIC, this.sharedContext.superTypeProvider)\n    ) {\n      throw new Error(`Term datatype ${term.datatype.value} with value ${term.value} has type ${term.termType} and is not a numeric literal`);\n    }\n    return <E.NumericLiteral> this.termTransformer.transformLiteral(term);\n  }\n\n  protected extractValue(term: RDF.Term): { value: any; type: string } {\n    if (term.termType !== 'Literal') {\n      throw new Error(`Term with value ${term.value} has type ${term.termType} and is not a literal`);\n    }\n\n    const transformedLit = this.termTransformer.transformLiteral(term);\n    return { type: transformedLit.dataType, value: transformedLit.typedValue };\n  }\n\n  public static emptyValue(): RDF.Term | undefined {\n    return undefined;\n  }\n\n  abstract init(start: RDF.Term): State;\n\n  abstract result(state: State): RDF.Term;\n\n  abstract put(state: State, bindings: RDF.Term): State;\n}\n"]}