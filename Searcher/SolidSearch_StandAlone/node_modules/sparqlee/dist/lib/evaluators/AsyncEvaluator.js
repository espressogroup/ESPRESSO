"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AsyncEvaluator = void 0;
const LRUCache = require("lru-cache");
const AlgebraTransformer_1 = require("../transformers/AlgebraTransformer");
const AsyncRecursiveEvaluator_1 = require("./evaluatorHelpers/AsyncRecursiveEvaluator");
class AsyncEvaluator {
    constructor(algExpr, context = {}) {
        this.algExpr = algExpr;
        // eslint-disable-next-line unicorn/no-useless-undefined
        const creator = context.extensionFunctionCreator || (() => undefined);
        const baseContext = AsyncEvaluator.completeContext(context);
        const transformer = new AlgebraTransformer_1.AlgebraTransformer(Object.assign({ type: 'async', creator }, baseContext));
        this.expr = transformer.transformAlgebra(algExpr);
        this.evaluator = new AsyncRecursiveEvaluator_1.AsyncRecursiveEvaluator(baseContext, transformer);
    }
    static completeContext(context) {
        return {
            now: context.now || new Date(Date.now()),
            baseIRI: context.baseIRI || undefined,
            functionArgumentsCache: context.functionArgumentsCache || {},
            superTypeProvider: {
                cache: context.typeCache || new LRUCache(),
                discoverer: context.getSuperType || (() => 'term'),
            },
            extensionFunctionCreator: context.extensionFunctionCreator,
            exists: context.exists,
            aggregate: context.aggregate,
            bnode: context.bnode,
        };
    }
    async evaluate(mapping) {
        const result = await this.evaluator.evaluate(this.expr, mapping);
        return result.toRDF();
    }
    async evaluateAsEBV(mapping) {
        const result = await this.evaluator.evaluate(this.expr, mapping);
        return result.coerceEBV();
    }
    async evaluateAsInternal(mapping) {
        return await this.evaluator.evaluate(this.expr, mapping);
    }
}
exports.AsyncEvaluator = AsyncEvaluator;
//# sourceMappingURL=AsyncEvaluator.js.map